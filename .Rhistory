q <- c(1,2,3)
costCreate <- rep(0.5,3)
costDestruct <- rep(0.5,3)
supplyList <- list(p,costDestruct, suppPoints)
demandList <- list(q,costCreate, demPoints)
BalancedExtensionSolver(supplyList, demandList, exp = 2)
costMatrix(suppPoints, demPoints)
suppPoints <- matrix(c(0,0,0,3,3.5,4,0,1,2,1.7,1,0.2), ncol = 2)
demPoints <- suppPoints
suppPoints
# supply measure
p <- c(2,2,2,0,0,0)
q <- c(0,0,0,1,2,3)
costCreate <- rep(0.5,6)
costDestruct <- rep(0.5,6)
supplyList <- list(p,costDestruct, suppPoints)
demandList <- list(q,costCreate, demPoints)
costMatrix(suppPoints, demPoints)
BalancedExtensionSolver(supplyList, demandList, exp = 2)
#' @param wfr (optional) Computes the cost matrix needed for the Wasserstein-Fisher-Rao distance \eqn{c(x,y) = -\log(\cos^2_+(d(x,y)))}{c(x,y) = -log(cos_+(d(x,y)²))}.
#' The default value is "false".
#' @param costMatrix (optional) Instead of having the algorithm compute the cost matrix, a custom cost matrix can be passed to the algorithm.
#' @param Monge (optional) Set to TRUE to use the Monge algorithm.
#'
#' @examples
#'
#'
#' @export
#'
BalancedExtensionSolver <- function(supplyList, demandList, method = "euclidean", exp = 1, p = 1, wfr = FALSE, Monge = FALSE, costMatrix = NULL){
if(is.null(costMatrix)){
costMatrix <- costMatrix(supplyList[[3]], demandList[[3]], method, exp, wfr, p)
}
if(Monge){
res <- mongeAlgorithm(costMatrix, supplyList[[1]], demandList[[1]], supplyList[[2]], demandList[[2]] )
}else{
supply <- c(supplyList[[1]], sum(demandList[[1]]))
demand <- c(demandList[[1]], sum(supplyList[[1]]))
costMatrix <- cbind(costMatrix, supplyList[[2]])
costMatrix <- rbind(costMatrix, c(demandList[[2]],0))
print(costMatrix)
print(supply)
print(demand)
transport <- transport::transport(supply, demand, costMatrix, method = "revsimplex")
cost <- 0
for (i in 1:nrow(res)){
cost = cost + res[i,3]*costMatrix[res[i,1], res[i,2]]
}
import <-rep(0, length(demandList[[2]]))
export <- rep(0, length(supplyList[[2]]))
expTransport <- res[res$to > length(demandList[[1]]) & res$from <= length(supplyList[[1]]) ,]
impTransport <- res[res$from > length(supplyList[[1]]) & res$to <= length(demandList[[1]]),]
import[impTransport$to] <- impTransport$mass
export[expTransport$from] <- expTransport$mass
res <- res[res$to <= length(demandList[[1]]) & res$from <= length(supplyList[[1]]),]
if(length(res$from) > 0){
transportPlan <- matrix(0,length(supplyList[[1]]),length(demandList[[1]]))
transportPlan[cbind(res$from,res$to)] <- res$mass
}else{
transportPlan <- matrix(0,length(supply),length(demand))
}
transport <- list(cost = cost, transportPlan = transportPlan, import = import, export = export)
}
return(transport)
}
#' @param wfr (optional) Computes the cost matrix needed for the Wasserstein-Fisher-Rao distance \eqn{c(x,y) = -\log(\cos^2_+(d(x,y)))}{c(x,y) = -log(cos_+(d(x,y)²))}.
#' The default value is "false".
#' @param costMatrix (optional) Instead of having the algorithm compute the cost matrix, a custom cost matrix can be passed to the algorithm.
#' @param Monge (optional) Set to TRUE to use the Monge algorithm.
#'
#' @examples
#'
#'
#' @export
#'
BalancedExtensionSolver <- function(supplyList, demandList, method = "euclidean", exp = 1, p = 1, wfr = FALSE, Monge = FALSE, costMatrix = NULL){
if(is.null(costMatrix)){
costMatrix <- costMatrix(supplyList[[3]], demandList[[3]], method, exp, wfr, p)
}
if(Monge){
res <- mongeAlgorithm(costMatrix, supplyList[[1]], demandList[[1]], supplyList[[2]], demandList[[2]] )
}else{
supply <- c(supplyList[[1]], sum(demandList[[1]]))
demand <- c(demandList[[1]], sum(supplyList[[1]]))
costMatrix <- cbind(costMatrix, supplyList[[2]])
costMatrix <- rbind(costMatrix, c(demandList[[2]],0))
print(costMatrix)
print(supply)
print(demand)
transport <- transport::transport(supply, demand, costMatrix, method = "revsimplex")
cost <- 0
for (i in 1:nrow(res)){
cost = cost + res[i,3]*costMatrix[res[i,1], res[i,2]]
}
import <-rep(0, length(demandList[[2]]))
export <- rep(0, length(supplyList[[2]]))
expTransport <- res[res$to > length(demandList[[1]]) & res$from <= length(supplyList[[1]]) ,]
impTransport <- res[res$from > length(supplyList[[1]]) & res$to <= length(demandList[[1]]),]
import[impTransport$to] <- impTransport$mass
export[expTransport$from] <- expTransport$mass
res <- res[res$to <= length(demandList[[1]]) & res$from <= length(supplyList[[1]]),]
if(length(res$from) > 0){
transportPlan <- matrix(0,length(supplyList[[1]]),length(demandList[[1]]))
transportPlan[cbind(res$from,res$to)] <- res$mass
}else{
transportPlan <- matrix(0,length(supply),length(demand))
}
transport <- list(cost = cost, transportPlan = transportPlan, import = import, export = export)
}
return(transport)
}
BalancedExtensionSolver(supplyList, demandList, exp = 2)
#' @param wfr (optional) Computes the cost matrix needed for the Wasserstein-Fisher-Rao distance \eqn{c(x,y) = -\log(\cos^2_+(d(x,y)))}{c(x,y) = -log(cos_+(d(x,y)²))}.
#' The default value is "false".
#' @param costMatrix (optional) Instead of having the algorithm compute the cost matrix, a custom cost matrix can be passed to the algorithm.
#' @param Monge (optional) Set to TRUE to use the Monge algorithm.
#'
#' @examples
#'
#'
#' @export
#'
BalancedExtensionSolver <- function(supplyList, demandList, method = "euclidean", exp = 1, p = 1, wfr = FALSE, Monge = FALSE, costMatrix = NULL){
if(is.null(costMatrix)){
costMatrix <- costMatrix(supplyList[[3]], demandList[[3]], method, exp, wfr, p)
}
print(costMatrix)
if(Monge){
res <- mongeAlgorithm(costMatrix, supplyList[[1]], demandList[[1]], supplyList[[2]], demandList[[2]] )
}else{
print(costMatrix)
supply <- c(supplyList[[1]], sum(demandList[[1]]))
demand <- c(demandList[[1]], sum(supplyList[[1]]))
print(costMatrix)
costMatrix <- cbind(costMatrix, supplyList[[2]])
costMatrix <- rbind(costMatrix, c(demandList[[2]],0))
print(costMatrix)
transport <- transport::transport(supply, demand, costMatrix, method = "revsimplex")
cost <- 0
for (i in 1:nrow(res)){
cost = cost + res[i,3]*costMatrix[res[i,1], res[i,2]]
}
import <-rep(0, length(demandList[[2]]))
export <- rep(0, length(supplyList[[2]]))
expTransport <- res[res$to > length(demandList[[1]]) & res$from <= length(supplyList[[1]]) ,]
impTransport <- res[res$from > length(supplyList[[1]]) & res$to <= length(demandList[[1]]),]
import[impTransport$to] <- impTransport$mass
export[expTransport$from] <- expTransport$mass
res <- res[res$to <= length(demandList[[1]]) & res$from <= length(supplyList[[1]]),]
if(length(res$from) > 0){
transportPlan <- matrix(0,length(supplyList[[1]]),length(demandList[[1]]))
transportPlan[cbind(res$from,res$to)] <- res$mass
}else{
transportPlan <- matrix(0,length(supply),length(demand))
}
transport <- list(cost = cost, transportPlan = transportPlan, import = import, export = export)
}
return(transport)
}
BalancedExtensionSolver(supplyList, demandList, exp = 2)
costMatrix(suppPoints, demPoints)
costMatrix(suppList[[3]], demandList[[3]])
suppList[[3]]
supplyList <- list(p,costDestruct, suppPoints)
demandList <- list(q,costCreate, demPoints)
suppList[[3]]
supplyList
supplyList[3]
supplyList[[3]]
supplyList[[3]]
costMatrix(supplyList[[3]], demandList[[3]])
costMatrix(supplyList[[3]], demandList[[3]], method = "euclidean", exp = 1, p = 2, wfr = FALSE)
#' @param wfr (optional) Computes the cost matrix needed for the Wasserstein-Fisher-Rao distance \eqn{c(x,y) = -\log(\cos^2_+(d(x,y)))}{c(x,y) = -log(cos_+(d(x,y)²))}.
#' The default value is "false".
#' @param costMatrix (optional) Instead of having the algorithm compute the cost matrix, a custom cost matrix can be passed to the algorithm.
#' @param Monge (optional) Set to TRUE to use the Monge algorithm.
#'
#' @examples
#'
#'
#' @export
#'
BalancedExtensionSolver <- function(supplyList, demandList, method = "euclidean", exp = 1, p = 2, wfr = FALSE, Monge = FALSE, costMatrix = NULL){
if(is.null(costMatrix)){
costMatrix <- costMatrix(supplyList[[3]], demandList[[3]], method, exp, p, wfr)
}
print(costMatrix)
if(Monge){
res <- mongeAlgorithm(costMatrix, supplyList[[1]], demandList[[1]], supplyList[[2]], demandList[[2]] )
}else{
print(costMatrix)
supply <- c(supplyList[[1]], sum(demandList[[1]]))
demand <- c(demandList[[1]], sum(supplyList[[1]]))
print(costMatrix)
costMatrix <- cbind(costMatrix, supplyList[[2]])
costMatrix <- rbind(costMatrix, c(demandList[[2]],0))
print(costMatrix)
transport <- transport::transport(supply, demand, costMatrix, method = "revsimplex")
cost <- 0
for (i in 1:nrow(res)){
cost = cost + res[i,3]*costMatrix[res[i,1], res[i,2]]
}
import <-rep(0, length(demandList[[2]]))
export <- rep(0, length(supplyList[[2]]))
expTransport <- res[res$to > length(demandList[[1]]) & res$from <= length(supplyList[[1]]) ,]
impTransport <- res[res$from > length(supplyList[[1]]) & res$to <= length(demandList[[1]]),]
import[impTransport$to] <- impTransport$mass
export[expTransport$from] <- expTransport$mass
res <- res[res$to <= length(demandList[[1]]) & res$from <= length(supplyList[[1]]),]
if(length(res$from) > 0){
transportPlan <- matrix(0,length(supplyList[[1]]),length(demandList[[1]]))
transportPlan[cbind(res$from,res$to)] <- res$mass
}else{
transportPlan <- matrix(0,length(supply),length(demand))
}
transport <- list(cost = cost, transportPlan = transportPlan, import = import, export = export)
}
return(transport)
}
BalancedExtensionSolver(supplyList, demandList, exp = 2)
#' @param wfr (optional) Computes the cost matrix needed for the Wasserstein-Fisher-Rao distance \eqn{c(x,y) = -\log(\cos^2_+(d(x,y)))}{c(x,y) = -log(cos_+(d(x,y)²))}.
#' The default value is "false".
#' @param costMatrix (optional) Instead of having the algorithm compute the cost matrix, a custom cost matrix can be passed to the algorithm.
#' @param Monge (optional) Set to TRUE to use the Monge algorithm.
#'
#' @examples
#'
#'
#' @export
#'
BalancedExtensionSolver <- function(supplyList, demandList, method = "euclidean", exp = 1, p = 2, wfr = FALSE, Monge = FALSE, costMatrix = NULL){
if(is.null(costMatrix)){
costMatrix <- costMatrix(supplyList[[3]], demandList[[3]], method, exp, p, wfr)
}
if(Monge){
res <- mongeAlgorithm(costMatrix, supplyList[[1]], demandList[[1]], supplyList[[2]], demandList[[2]] )
}else{
supply <- c(supplyList[[1]], sum(demandList[[1]]))
demand <- c(demandList[[1]], sum(supplyList[[1]]))
costMatrix <- cbind(costMatrix, supplyList[[2]])
costMatrix <- rbind(costMatrix, c(demandList[[2]],0))
transport <- transport::transport(supply, demand, costMatrix, method = "revsimplex")
print(transport())
cost <- 0
for (i in 1:nrow(res)){
cost = cost + res[i,3]*costMatrix[res[i,1], res[i,2]]
}
import <-rep(0, length(demandList[[2]]))
export <- rep(0, length(supplyList[[2]]))
expTransport <- res[res$to > length(demandList[[1]]) & res$from <= length(supplyList[[1]]) ,]
impTransport <- res[res$from > length(supplyList[[1]]) & res$to <= length(demandList[[1]]),]
import[impTransport$to] <- impTransport$mass
export[expTransport$from] <- expTransport$mass
res <- res[res$to <= length(demandList[[1]]) & res$from <= length(supplyList[[1]]),]
if(length(res$from) > 0){
transportPlan <- matrix(0,length(supplyList[[1]]),length(demandList[[1]]))
transportPlan[cbind(res$from,res$to)] <- res$mass
}else{
transportPlan <- matrix(0,length(supply),length(demand))
}
transport <- list(cost = cost, transportPlan = transportPlan, import = import, export = export)
}
return(transport)
}
BalancedExtensionSolver(supplyList, demandList, exp = 2)
#' @param wfr (optional) Computes the cost matrix needed for the Wasserstein-Fisher-Rao distance \eqn{c(x,y) = -\log(\cos^2_+(d(x,y)))}{c(x,y) = -log(cos_+(d(x,y)²))}.
#' The default value is "false".
#' @param costMatrix (optional) Instead of having the algorithm compute the cost matrix, a custom cost matrix can be passed to the algorithm.
#' @param Monge (optional) Set to TRUE to use the Monge algorithm.
#'
#' @examples
#'
#'
#' @export
#'
BalancedExtensionSolver <- function(supplyList, demandList, method = "euclidean", exp = 1, p = 2, wfr = FALSE, Monge = FALSE, costMatrix = NULL){
if(is.null(costMatrix)){
costMatrix <- costMatrix(supplyList[[3]], demandList[[3]], method, exp, p, wfr)
}
if(Monge){
res <- mongeAlgorithm(costMatrix, supplyList[[1]], demandList[[1]], supplyList[[2]], demandList[[2]] )
}else{
supply <- c(supplyList[[1]], sum(demandList[[1]]))
demand <- c(demandList[[1]], sum(supplyList[[1]]))
costMatrix <- cbind(costMatrix, supplyList[[2]])
costMatrix <- rbind(costMatrix, c(demandList[[2]],0))
transport <- transport::transport(supply, demand, costMatrix, method = "revsimplex")
print(transport)
cost <- 0
for (i in 1:nrow(res)){
cost = cost + res[i,3]*costMatrix[res[i,1], res[i,2]]
}
import <-rep(0, length(demandList[[2]]))
export <- rep(0, length(supplyList[[2]]))
expTransport <- res[res$to > length(demandList[[1]]) & res$from <= length(supplyList[[1]]) ,]
impTransport <- res[res$from > length(supplyList[[1]]) & res$to <= length(demandList[[1]]),]
import[impTransport$to] <- impTransport$mass
export[expTransport$from] <- expTransport$mass
res <- res[res$to <= length(demandList[[1]]) & res$from <= length(supplyList[[1]]),]
if(length(res$from) > 0){
transportPlan <- matrix(0,length(supplyList[[1]]),length(demandList[[1]]))
transportPlan[cbind(res$from,res$to)] <- res$mass
}else{
transportPlan <- matrix(0,length(supply),length(demand))
}
transport <- list(cost = cost, transportPlan = transportPlan, import = import, export = export)
}
return(transport)
}
BalancedExtensionSolver(supplyList, demandList, exp = 2)
#' @param wfr (optional) Computes the cost matrix needed for the Wasserstein-Fisher-Rao distance \eqn{c(x,y) = -\log(\cos^2_+(d(x,y)))}{c(x,y) = -log(cos_+(d(x,y)²))}.
#' The default value is "false".
#' @param costMatrix (optional) Instead of having the algorithm compute the cost matrix, a custom cost matrix can be passed to the algorithm.
#' @param Monge (optional) Set to TRUE to use the Monge algorithm.
#'
#' @examples
#'
#'
#' @export
#'
BalancedExtensionSolver <- function(supplyList, demandList, method = "euclidean", exp = 1, p = 2, wfr = FALSE, Monge = FALSE, costMatrix = NULL){
if(is.null(costMatrix)){
costMatrix <- costMatrix(supplyList[[3]], demandList[[3]], method, exp, p, wfr)
}
if(Monge){
res <- mongeAlgorithm(costMatrix, supplyList[[1]], demandList[[1]], supplyList[[2]], demandList[[2]] )
}else{
supply <- c(supplyList[[1]], sum(demandList[[1]]))
demand <- c(demandList[[1]], sum(supplyList[[1]]))
costMatrix <- cbind(costMatrix, supplyList[[2]])
costMatrix <- rbind(costMatrix, c(demandList[[2]],0))
res <- transport::transport(supply, demand, costMatrix, method = "revsimplex")
print(res)
cost <- 0
for (i in 1:nrow(res)){
cost = cost + res[i,3]*costMatrix[res[i,1], res[i,2]]
}
import <-rep(0, length(demandList[[2]]))
export <- rep(0, length(supplyList[[2]]))
expTransport <- res[res$to > length(demandList[[1]]) & res$from <= length(supplyList[[1]]) ,]
impTransport <- res[res$from > length(supplyList[[1]]) & res$to <= length(demandList[[1]]),]
import[impTransport$to] <- impTransport$mass
export[expTransport$from] <- expTransport$mass
res <- res[res$to <= length(demandList[[1]]) & res$from <= length(supplyList[[1]]),]
if(length(res$from) > 0){
transportPlan <- matrix(0,length(supplyList[[1]]),length(demandList[[1]]))
transportPlan[cbind(res$from,res$to)] <- res$mass
}else{
transportPlan <- matrix(0,length(supply),length(demand))
}
transport <- list(cost = cost, transportPlan = transportPlan, import = import, export = export)
}
return(transport)
}
BalancedExtensionSolver(supplyList, demandList, exp = 2)
costCreate <- rep(0.1,6)
costDestruct <- rep(0.1,6)
supplyList <- list(p,costDestruct, suppPoints)
demandList <- list(q,costCreate, demPoints)
BalancedExtensionSolver(supplyList, demandList, exp = 2)
costCreate <- rep(2,6)
costDestruct <- rep(2,6)
supplyList <- list(p,costDestruct, suppPoints)
demandList <- list(q,costCreate, demPoints)
BalancedExtensionSolver(supplyList, demandList, exp = 2)
costCreate <- rep(4,6)
costDestruct <- rep(4,6)
supplyList <- list(p,costDestruct, suppPoints)
demandList <- list(q,costCreate, demPoints)
BalancedExtensionSolver(supplyList, demandList, exp = 2)
costCreate <- rep(10,6)
costDestruct <- rep(10,6)
supplyList <- list(p,costDestruct, suppPoints)
demandList <- list(q,costCreate, demPoints)
BalancedExtensionSolver(supplyList, demandList, exp = 2)
suppPoints <- matrix(c(0,0,0,0,1,2), ncol = 2)
suppPoints
suppPoints <- matrix(c(0,0,0,0,1,2), ncol = 2)
suppPoints
demPoints <- matrix(c(3,3.5,4,1.7,1,0.2), ncol = 2)
deMPoints
demPoints
suppPoints <- matrix(c(0,0,0,0,1,2), ncol = 2)
suppPoints
demPoints <- matrix(c(3,3.5,4,1.7,1,0.2), ncol = 2)
demPoints
# supply measure
p <- c(2,2,2)
q <- c(1,2,3)
costCreate <- rep(10,3)
costDestruct <- rep(10,3)
supplyList <- list(p,costDestruct, suppPoints)
demandList <- list(q,costCreate, demPoints)
BalancedExtensionSolver(supplyList, demandList, exp = 2)
supplyPoints <- matrix(c(0,0,0,0,1,2), ncol = 2)
demandPoints <- matrix(c(3,3.5,4,1.7,1,0.2), ncol = 2)
# supply measure
p <- c(2,2,2)
q <- c(1,2,3)
costCreate <- rep(10,3)
costDestruct <- rep(10,3)
supplyList <- list(p,costDestruct, supplyPoints)
demandList <- list(q,costCreate, demandPoints)
BalancedExtensionSolver(supplyList, demandList, exp = 2)
inseg <- function(x,s1,s2){
#'    if(s1 <= x & x <= s2){
#'        return(1)
#'    }else{
#'        return(0)
#'    }
#' }
#'
#'
#'
#' fp <- function(x){
#'     r <- 2*inseg(x,0.0,0.2)
#'     r <- r + 40*(x-0.9)*inseg(x,0.9,0.95)
#'     r <- r + 40*(1-x)*inseg(x,0.95,1)
#'     return(r)
#' }
#'
#' fq <- function(y){
#'     r <- 10*(y-0.2)*inseg(y,0.2,0.4)
#'     r <- r + 1.3*(sqrt(as.complex(1-(y-0.7)^2/0.04)))*inseg(y,0.5,0.9)
#'     r <- Re(r)
#'     return(r)
#' }
#'
#' I <- 1000
#' J <- 1000
#' X <- seq(0,1,length.out = I)
#' Y <- seq(0,1,length.out = J)
#' p <- sapply(X, fp)
#' p[1] <- 0
#' p[I] <- 0
#' q <- sapply(Y, fq)
#' q <- q*sum(p)/sum(q)
)
inseg <- function(x,s1,s2){
if(s1 <= x & x <= s2){
return(1)
}else{
return(0)
}
}
fp <- function(x){
r <- 2*inseg(x,0.0,0.2)
r <- r + 40*(x-0.9)*inseg(x,0.9,0.95)
r <- r + 40*(1-x)*inseg(x,0.95,1)
return(r)
}
fq <- function(y){
r <- 10*(y-0.2)*inseg(y,0.2,0.4)
r <- r + 1.3*(sqrt(as.complex(1-(y-0.7)^2/0.04)))*inseg(y,0.5,0.9)
r <- Re(r)
return(r)
}
I <- 1000
J <- 1000
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
supply <- list(p,X)
demand <- list(q,Y)
p
usethis::use_data(p, supply)
demand <- q*sum(p)/sum(q)
demand
usethis::use_data(demand)
library(unbalancedTransport)
load("~/Documents/Master/Masterarbeit/unbalancedTransport/data/demandExample.rda")
load("~/Documents/Master/Masterarbeit/unbalancedTransport/data/supplyExample.rda")
usethis::use_data(demandExample)
inseg <- function(x,s1,s2){
if(s1 <= x & x <= s2){
return(1)
}else{
return(0)
}
}
fp <- function(x){
r <- 2*inseg(x,0.0,0.2)
r <- r + 40*(x-0.9)*inseg(x,0.9,0.95)
r <- r + 40*(1-x)*inseg(x,0.95,1)
return(r)
}
fq <- function(y){
r <- 10*(y-0.2)*inseg(y,0.2,0.4)
r <- r + 1.3*(sqrt(as.complex(1-(y-0.7)^2/0.04)))*inseg(y,0.5,0.9)
r <- Re(r)
return(r)
}
I <- 1000
J <- 1000
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
q <- sapply(Y, fq)
demand <- q*sum(p)/sum(q)
p
q
supplyExample <- p
demandExample <- q
usethis::use_data(demandExample)
usethis::use_data(supplyExample)
library(unbalancedTransport)
