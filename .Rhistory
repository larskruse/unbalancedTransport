I <- 1000
J <- 1000
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 10000
# vector of epsilon values
epsvec <- seq(-1,-7, length.out = 20)
epsvec <- 10^(epsvec)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
cat("The quadratic cost is used. \n")
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
# compute and plot the transport plan
# res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
#
# print(res$TransportCost)
#
# plot1DTransport(res$TransportPlan, supplyList, demandList)
# plotUOTP(res$TransportPlan)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The TV divergence with parameter 0.05 is used for both supply and demand vectors.\n")
cat("The quadratic cost is used.\n")
#compute quadrature cost matrix
C <-  costMatrix(X, Y, exp = 2)
# use Total Variation with lambda = 0.05 for supply and demand
supply <- list("TV", p, 0.05)
demand <- list("TV", q, 0.05)
print(supply[1:10])
print(demand[1:10])
# compute and plot the transport plan
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
print(res$TransportCost)
plot1DTransport(res$TransportPlan, supplyList, demandList)
plotUOTP(res$TransportPlan)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand vectors.\n")
cat("The WFR distance matrix is used.\n")
#compute Wasserstein-Fisher-Rao cost matrix
C <- wfrCost(X,Y)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
# compute and plot the transport plan
# res <- scalingAlgorithmFromCost(C, supply, demand, 20000, epsvec)
# print(res$TransportCost)
# plot1DTransport(res$TransportPlan, supplyList, demandList)
# plotUOTP(res$TransportPlan)
C <-  costMatrix(X, Y, exp = 2)
supply <- list("RG", p, 0.7, 1.2)
demand <- list("RG", q, 0.7, 1.2)
# compute and plot the transport plan
# res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
# print(res$TransportCost)
# plot1DTransport(res$TransportPlan, supplyList, demandList)
# plotUOTP(res$TransportPlan)
}
ExampleScaling()
#' The Scaling Algorithm Example
#'
#' The examples given in the [paper]
#'
#' @export
#'
ExampleScaling <- function(){
print("This function uses the example distributions used in the scaling paper.")
# number of supply and demand points
I <- 1000
J <- 1000
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 10000
# vector of epsilon values
epsvec <- seq(-1,-7, length.out = 20)
epsvec <- 10^(epsvec)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
cat("The quadratic cost is used. \n")
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
# compute and plot the transport plan
# res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
#
# print(res$TransportCost)
#
# plot1DTransport(res$TransportPlan, supplyList, demandList)
# plotUOTP(res$TransportPlan)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The TV divergence with parameter 0.05 is used for both supply and demand vectors.\n")
cat("The quadratic cost is used.\n")
#compute quadrature cost matrix
C <-  costMatrix(X, Y, exp = 2)
# use Total Variation with lambda = 0.05 for supply and demand
supply <- list("TV", p, 0.05)
demand <- list("TV", q, 0.05)
print(supply[[1]])
print(supply[[2]][1:10])
print(supply[[3]])
print(demand[[1]])
print(demand[[2]][1:10])
print(demand[[3]])
# compute and plot the transport plan
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
print(res$TransportCost)
plot1DTransport(res$TransportPlan, supplyList, demandList)
plotUOTP(res$TransportPlan)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand vectors.\n")
cat("The WFR distance matrix is used.\n")
#compute Wasserstein-Fisher-Rao cost matrix
C <- wfrCost(X,Y)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
# compute and plot the transport plan
# res <- scalingAlgorithmFromCost(C, supply, demand, 20000, epsvec)
# print(res$TransportCost)
# plot1DTransport(res$TransportPlan, supplyList, demandList)
# plotUOTP(res$TransportPlan)
C <-  costMatrix(X, Y, exp = 2)
supply <- list("RG", p, 0.7, 1.2)
demand <- list("RG", q, 0.7, 1.2)
# compute and plot the transport plan
# res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
# print(res$TransportCost)
# plot1DTransport(res$TransportPlan, supplyList, demandList)
# plotUOTP(res$TransportPlan)
}
ExampleScaling()
#' The Scaling Algorithm Example
#'
#' The examples given in the [paper]
#'
#' @export
#'
ExampleScaling <- function(){
print("This function uses the example distributions used in the scaling paper.")
# number of supply and demand points
I <- 1000
J <- 1000
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 10000
# vector of epsilon values
epsvec <- seq(-1,-7, length.out = 20)
epsvec <- 10^(epsvec)
# cat("Number of iterations: ", iterMax, "\n")
#
# cat("Epsilon values: ", epsvec, "\n")
#
# cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
#
# cat("The quadratic cost is used. \n")
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
# compute and plot the transport plan
# res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
#
# print(res$TransportCost)
#
# plot1DTransport(res$TransportPlan, supplyList, demandList)
# plotUOTP(res$TransportPlan)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The TV divergence with parameter 0.05 is used for both supply and demand vectors.\n")
cat("The quadratic cost is used.\n")
#compute quadrature cost matrix
C <-  costMatrix(X, Y, exp = 2)
# use Total Variation with lambda = 0.05 for supply and demand
supply <- list("TV", p, 0.05)
demand <- list("TV", q, 0.05)
print(supply[[1]])
print(supply[[2]][1:10])
print(supply[[3]])
print(demand[[1]])
print(demand[[2]][1:10])
print(demand[[3]])
# compute and plot the transport plan
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
print(res$TransportCost)
plot1DTransport(res$TransportPlan, supplyList, demandList)
plotUOTP(res$TransportPlan)
# cat("Number of iterations: ", iterMax, "\n")
#
# cat("Epsilon values: ", epsvec, "\n")
#
# cat("The KL divergence with parameter 0.5 is used for both supply and demand vectors.\n")
#
# cat("The WFR distance matrix is used.\n")
#compute Wasserstein-Fisher-Rao cost matrix
C <- wfrCost(X,Y)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
# compute and plot the transport plan
# res <- scalingAlgorithmFromCost(C, supply, demand, 20000, epsvec)
# print(res$TransportCost)
# plot1DTransport(res$TransportPlan, supplyList, demandList)
# plotUOTP(res$TransportPlan)
C <-  costMatrix(X, Y, exp = 2)
supply <- list("RG", p, 0.7, 1.2)
demand <- list("RG", q, 0.7, 1.2)
# compute and plot the transport plan
# res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
# print(res$TransportCost)
# plot1DTransport(res$TransportPlan, supplyList, demandList)
# plotUOTP(res$TransportPlan)
}
ExampleScaling()
max(c(1,2,3,4,5))
max(32,5,3,2)
max(1,5,4,3,5,6,7,c(1,46,4))
proxdiv(1, c(1), c(1), c(1), 1,1)
proxdiv(1, c(1), c(1), c(1), 1,1,0,0)
proxdiv(1, c(seq(0.01,10,by = 0.1)), c(1), c(1), 1,1,0,0)
proxdiv(1, c(1), c(seq(0.01,10,by = 0.1)), c(1), c(1), 1,1,0,0)
proxdiv(1, c(1), c(seq(0.01,10,by = 0.1)), c(1), 1,1,0,0)
proxdiv(1, c(1), c(1), c(seq(0.01,10,by = 0.1)), 1,1,0,0)
plot(proxdiv(1, c(1), c(1), c(seq(0.01,10,by = 0.1)), 1,1,0,0))
plot(proxdiv(1, c(1), seq(0.01, 10, by = 0.01) ,c(0),0.1,1,1,1))
seq(0.01, 10, by = 0.01)
length(seq(0.01, 10, by = 0.01))
plot(proxdiv(1, rep(1,1000), seq(0.01, 10, by = 0.01) ,rep(0,1000),0.1,1,1,1))
plot(proxdiv(1, rep(1,1000), log(seq(0.01, 10, by = 0.01)) ,rep(0,1000),0.1,1,1,1))
plot(proxdiv(1, rep(1,1000), exp(seq(0.01, 10, by = 0.01)) ,rep(0,1000),0.1,1,1,1))
plot(proxdiv(1, rep(1,1000), exp(seq(0.01, 10, by = 0.01)) ,rep(0,1000),0.1,2,1,1))
plot(proxdiv(1, rep(1,1000), exp(seq(0.01, 10, by = 0.01)) ,rep(0,1000),0.1,3,1,1))
plot(proxdiv(1, rep(1,1000), exp(seq(0.01, 10, by = 0.01)) ,rep(0,1000),0.1,3,1,1), exp(seq(0.01, 10, by = 0.01)))
plot(proxdiv(1, rep(1,1000), 10^(seq(-1, 1, by = 0.01)) ,rep(0,1000),0.1,3,1,1), 10^(seq(-1, 1, by = 0.01)))
plot(proxdiv(1, rep(1,1000), 10^(seq(-1, 1, by = 0.01)) ,rep(0,1000),0.1,3,1,1), 10^(seq(-1, 1, by = 0.01)))
10^(seq(-1, 1, by = 0.01)
)
lenght(10^(seq(-1, 1, by = 0.01)))
length(10^(seq(-1, 1, by = 0.01)))
plot(proxdiv(1, rep(1,201), 10^(seq(-1, 1, by = 0.01)) ,rep(0,201),0.1,3,1,1), 10^(seq(-1, 1, by = 0.01)))
plot(proxdiv(1, rep(1,201), 10^(seq(-1, 1, by = 0.01)) ,rep(0,201),0.1,1,1,1), 10^(seq(-1, 1, by = 0.01)))
plot(proxdiv(1, rep(1,201), 10^(seq(-1, 1, by = 0.01)) ,rep(0,201),0.1,2,1,1), 10^(seq(-1, 1, by = 0.01)))
plot(proxdiv(1, rep(1,201), 10^(seq(-1, 1, by = 0.01)) ,rep(0,201),0.1,3,1,1), 10^(seq(-1, 1, by = 0.01)))
plot(proxdiv(1, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,3,1,1), 10^(seq(-1, 1, by = 0.01)))
plot(proxdiv(1, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,3,1,1), 10^(seq(-1, 1, by = 0.01)))
10^(seq(-1, 1, by = 0.01))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(1, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,3,1,1))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(1, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,1,1,1))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(1, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,2,1,1))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,2,1,1))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.01, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,2,1,1))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.1, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,2,1,1))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.3, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,2,1,1))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,2,1,1))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,1,1,1))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,2,1,1))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,3,1,1))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,3,0.2,0.5))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,3,0.5,2))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,3,2,4))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(123, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,3,2,4))
plot(10^(seq(-1, 1, by = 0.01)),log(proxdiv(0.3, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,3,2,4)))
plot(10^(seq(-1, 1, by = 0.01)),log(proxdiv(0.3, rep(1,201), exp(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,3,2,4)))
plot(10^(seq(-1, 1, by = 0.01)),log(proxdiv(0.3, rep(1,201), exp(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,1,2,4)))
plot(10^(seq(-1, 1, by = 0.01)),log(proxdiv(0.3, rep(1,201), exp(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,2,2,4)))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,2,1,1))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,2,1,133))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,2,1,1))
plot(10^(seq(-1, 1, by = 0.01)),log(proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,2,1,1)))
plot(10^(seq(-1, 1, by = 0.01)),log10(proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,2,1,1)))
plot(10^(seq(-1, 1, by = 0.01)),log10(proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,1,1,1)))
plot(10^(seq(-1, 1, by = 0.01)),log(log10(proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,1,1,1))))
plot(10^(seq(-1, 1, by = 0.01)),log(proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,1,1,1)))
plot(10^(seq(-1, 1, by = 0.01)),log(proxdiv(0.1, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,1,1,1)))
plot(10^(seq(-1, 1, by = 0.01)),log(proxdiv(0.15, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,1,1,1)))
proxdiv(0.1, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,1,1,1)
sqrt(2)
sqrt(1/0.1)
sqrt(1/0.01)
sqrt(1/1.5)
proxdiv(0.1, rep(1,5), c(0.01,0.1,0.5,1,1.5) ,rep(0,5),0.1,1,1,1)
proxdiv(0.1, rep(1,5), c(0.01,0.1,0.5,1,1.5) ,rep(1,5),0.1,1,1,1)
exp(-1/(0.2))
e^-1
exp(-1)
1/exp(1)
1/0.01
1/0.1
1/0.5
1/1.5
1/5
proxdiv(0.1, rep(1,5), c(0.01,0.1,0.5,1,1.5,5) ,rep(0,5),0.1,2,1,1)
proxdiv(0.1, rep(1,6), c(0.01,0.1,0.5,1,1.5,5) ,rep(0,6),0.1,2,1,1)
proxdiv(0.1, rep(1,6), c(0.01,0.1,0.5,1,1.5,5) ,rep(0,6),0.1,3,0.5,2)
1/c(0.01,0.1,0.5,1,1.5,5)
0.5*1/c(0.01,0.1,0.5,1,1.5,5)
2*1/c(0.01,0.1,0.5,1,1.5,5)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
proxdiv(0.1, rep(1,6), c(0.01,0.1,0.5,1,1.5,5) ,rep(0,6),0.1,3,0.5,2)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
proxdiv(0.1, rep(1,6), c(0.01,0.1,0.5,1,1.5,5) ,rep(0,6),0.1,3,0.5,2)
0.5*1/c(0.01,0.1,0.5,1,1.5,5)
2*1/c(0.01,0.1,0.5,1,1.5,5)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
proxdiv(0.1, rep(1,6), c(0.01,0.1,0.5,1,1.5,5) ,rep(0,6),0.1,3,0.5,2)
0.5*1/c(0.01,0.1,0.5,1,1.5,5)
2*1/c(0.01,0.1,0.5,1,1.5,5)
plot(10^(seq(-1, 1, by = 0.01)),log(proxdiv(0.3, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,3,2,4)))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.3, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,3,2,4))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.3, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,3,2,4))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.3, rep(1,201), 10^(seq(-2, 1, by = 0.01)) ,rep(0,201),0.1,3,1,4))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.3, rep(1,101), 10^(seq(-1, 1, by = 0.01)) ,rep(0,101),0.1,3,1,4))
plot(10^(seq(-1, 1, by = 0.01)),proxdiv(0.3, rep(1,100), 10^(seq(-1, 1, by = 0.01)) ,rep(0,100),0.1,3,1,4))
proxdiv(0.1, rep(1,6), c(0.01,0.1,0.5,1,1.5,5) ,rep(0,6),0.1,3,0.5,2)
plot(proxdiv(0.1, rep(1,6), c(0.01,0.1,0.5,1,1.5,5) ,rep(0,6),0.1,3,0.5,2))
plot(proxdiv(0.1, rep(1,6), c(0.05,0.1,0.5,1,1.5,5) ,rep(0,6),0.1,3,0.5,2))
plot(proxdiv(0.1, rep(1,100), seq(0.05,5,length.out = 100) ,rep(0,100),0.1,3,0.5,2))
plot(log(proxdiv(0.1, rep(1,100), seq(0.05,5,length.out = 100) ,rep(0,100),0.1,3,0.5,2)))
plot(log10(proxdiv(0.1, rep(1,100), seq(0.05,5,length.out = 100) ,rep(0,100),0.1,3,0.5,2)))
library(unbalancedTransport)
library(unbalancedTransport)
#' The Scaling Algorithm Example
#'
#' The examples given in the [paper]
#'
#' @export
#'
ExampleScaling <- function(){
print("This function uses the example distributions used in the scaling paper.")
# number of supply and demand points
I <- 1000
J <- 1000
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 10000
# vector of epsilon values
epsvec <- seq(-1,-7, length.out = 20)
epsvec <- 10^(epsvec)
# cat("Number of iterations: ", iterMax, "\n")
#
# cat("Epsilon values: ", epsvec, "\n")
#
# cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
#
# cat("The quadratic cost is used. \n")
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
# compute and plot the transport plan
# res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
#
# print(res$TransportCost)
#
# plot1DTransport(res$TransportPlan, supplyList, demandList)
# plotUOTP(res$TransportPlan)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The TV divergence with parameter 0.05 is used for both supply and demand vectors.\n")
cat("The quadratic cost is used.\n")
#compute quadrature cost matrix
C <-  costMatrix(X, Y, exp = 2)
# use Total Variation with lambda = 0.05 for supply and demand
supply <- list("TV", p, 0.05)
demand <- list("TV", q, 0.05)
print(supply[[1]])
print(supply[[2]][1:10])
print(supply[[3]])
print(demand[[1]])
print(demand[[2]][1:10])
print(demand[[3]])
# compute and plot the transport plan
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
print(res$TransportCost)
plot1DTransport(res$TransportPlan, supplyList, demandList)
plotUOTP(res$TransportPlan)
# cat("Number of iterations: ", iterMax, "\n")
#
# cat("Epsilon values: ", epsvec, "\n")
#
# cat("The KL divergence with parameter 0.5 is used for both supply and demand vectors.\n")
#
# cat("The WFR distance matrix is used.\n")
#compute Wasserstein-Fisher-Rao cost matrix
C <- wfrCost(X,Y)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
# compute and plot the transport plan
# res <- scalingAlgorithmFromCost(C, supply, demand, 20000, epsvec)
# print(res$TransportCost)
# plot1DTransport(res$TransportPlan, supplyList, demandList)
# plotUOTP(res$TransportPlan)
C <-  costMatrix(X, Y, exp = 2)
supply <- list("RG", p, 0.7, 1.2)
demand <- list("RG", q, 0.7, 1.2)
# compute and plot the transport plan
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
print(res$TransportCost)
plot1DTransport(res$TransportPlan, supplyList, demandList)
plotUOTP(res$TransportPlan)
}
ExampleScaling()
library(unbalancedTransport)
ExampleScaling()
library(unbalancedTransport)
library(unbalancedTransport)
kernel <- matrix(c(0.5,0.2,0.1,0.7), nrow = 2)
originKernel <- matrix(c(0.1,0.7,0.2,0.9), nrow = 2)
DivS <- 1
DivD <- 1
sup <- c(1.2, 0.7)
dem <- c(0.3, 1.1)
lamS <- 0.2
lamD <- 0.3
u <- c(0)
v <- c(0)
eps = 0.1
parS <- 1.5
parD <- 1.4
library(unbalancedTransport)
library(unbalancedTransport)
kernel <- matrix(c(0.5,0.2,0.1,0.7), nrow = 2)
originKernel <- matrix(c(0.1,0.7,0.2,0.9), nrow = 2)
DivS <- 1
DivD <- 1
sup <- c(1.2, 0.7)
dem <- c(0.3, 1.1)
lamS <- 0.2
lamD <- 0.3
u <- c(0)
v <- c(0)
eps = 0.1
parS <- 1.5
parD <- 1.4
testPrimalDual(kernel, originKernel, DivS, DivD, sup, dem, lamS, lamD, u, v, eps, parS, parD)
DivS <- 2
DivD <- 2
testPrimalDual(kernel, originKernel, DivS, DivD, sup, dem, lamS, lamD, u, v, eps, parS, parD)
DivS <- 3
DivD <- 3
testPrimalDual(kernel, originKernel, DivS, DivD, sup, dem, lamS, lamD, u, v, eps, parS, parD)
