g <- lambdaSupply/(eps+lambdaSupply) * g
# print(g)
#temp <-  sweep(-(sweep(t(costMatrix),2,g,"-")/eps), 2, logDem, "+")
# print(costMatrix)
temp <- sweep(costMatrix,2,g,"-")
# print(temp)
temp <- -temp
temp <- temp/eps
# print(temp)
temp <- sweep(temp, 2, logDem, "+")
# print(temp)
f <- colLogSumExps(t(temp))
# print(f)
f <- -eps*f
# print(f)
f <- lambdaDemand/(eps+lambdaDemand)  * f
# print(f)
}
# print("f / g")
#
# print(f)
# print(g)
for(i in 1:Nx){
for(j in 1:Ny){
tPlan[i,j] <- exp((f[i] + g[j] -costMatrix[i,j])/eps)
}
}
tPlan <- tPlan * (supply %*% t(demand))
return(list(f,g,tPlan))
}
start_time <- Sys.time()
res <- sink(C, supplyy, demandy, supplyReg, supplyAlpha,
supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
Div2, iterMax, epsvec)
res
end_time <- Sys.time()
nn <- 250
pa1 <- seq(0,0.2, length.out=nn)
pa1
a1 <- rep(1,nn)
a1[1] <- 0
a1[nn] <- 0
a1 <- a1/sum(a1)
a1 <- 0.65*a1
a1
pa2 <- seq(0.9,1, length.out = nn)
a2 <- 0.05-abs(pa2-0.95)
a2[0] <- 0
a2[nn] <- 0
a2 = a2/sum(a2)
a2 <- a2*0.35
a2
p = c(a1,a2)
X = c(pa1, pa2)
qa1 <- seq(0.2,0.4, length.out=nn)
b1 <- seq(0,1,length.out = nn)
b1[0] <- 0
b1[nn] <- 0
b1 <- b1/sum(b1)
b1 <- b1*0.45
qa2 <- seq(0.5,0.9, length.out = nn)
b2 <- sqrt(abs(1-((qa2-0.7)/0.2)^2))
b2[1] <- 0
b2[nn] <- 0
b2 <- b2/sum(b2)
b2 <- 0.55*b2
b2
q <- c(b1, b2)
Y <- c(qa1, qa2)
X
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.05)
demand <- list("KL", q, 0.05)
# number of iterations
iterMax <- 1000
# vector of epsilon values
epsvec <- 10^(-3)
library(unbalancedTransport)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
supplyy <- supply[[2]]
demandy <- demand[[2]]
Div1 <- 1
supplyReg <- supply[[3]]
Div2 <- 1
demandReg <- demand[[3]]
supplyy <- supply[[2]]
demandy <- demand[[2]]
start_time <- Sys.time()
res <- sink(C, supplyy, demandy, supplyReg, supplyAlpha,
supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
Div2, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plotUOTP(res[[3]])
plotUOTP(ress$TransportPlan)
library(unbalancedTransport)
start_time <- Sys.time()
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
# number of iterations
iterMax <- 1000
# vector of epsilon values
epsvec <- 10^(-3)
nn <- 500
pa1 <- seq(0,0.2, length.out=nn)
pa1
a1 <- rep(1,nn)
a1[1] <- 0
a1[nn] <- 0
a1 <- a1/sum(a1)
a1 <- 0.65*a1
a1
pa2 <- seq(0.9,1, length.out = nn)
a2 <- 0.05-abs(pa2-0.95)
a2[0] <- 0
a2[nn] <- 0
a2 = a2/sum(a2)
a2 <- a2*0.35
a2
p = c(a1,a2)
X = c(pa1, pa2)
qa1 <- seq(0.2,0.4, length.out=nn)
b1 <- seq(0,1,length.out = nn)
b1[0] <- 0
b1[nn] <- 0
b1 <- b1/sum(b1)
b1 <- b1*0.45
qa2 <- seq(0.5,0.9, length.out = nn)
b2 <- sqrt(abs(1-((qa2-0.7)/0.2)^2))
b2[1] <- 0
b2[nn] <- 0
b2 <- b2/sum(b2)
b2 <- 0.55*b2
b2
q <- c(b1, b2)
Y <- c(qa1, qa2)
X
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.05)
demand <- list("KL", q, 0.05)
start_time <- Sys.time()
end_time <- Sys.time()
print(end_time - start_time)
start_time <- Sys.time()
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
library(unbalancedTransport)
init_vectors(1,c(1,2),1,0,0)
library(unbalancedTransport)
init_vectors(1,c(1,2),1,0,0)
init_vectors(1.1,c(1,2),1,0,0)
-1.1*log(3)
library(unbalancedTransport)
library(unbalancedTransport)
init_vectors(1.1,c(1,2),1,0,0)
C
C <- matrix(c(1.5,2,3,4),2,2)
init_vectors(1.1, C,c(1,2), c(1.1,2.2), 1,0,0,2,2)
1.1*log(3)
1.1*log(2)
init_vectors(1.1, C,c(1,2), c(1.1,2.2), 2,0,0,2,2)
log(3)
init_vectors(1.1, C,c(1,2), c(1.1,2.2), 3,0,0,2,2)
init_vectors(1.1, C,c(1,2), c(1.1,2.2), 4,0,0,2,2)
init_vectors(1.1, C,c(1,2), c(1.1,2.2), 4,0.3,0,2,2)
library(unbalancedTransport)
init_vectors(1.1, C,c(1,2), c(1.1,2.2), 4,0.3,0,2,2)
init_vectors(1.1, C,c(1,2), c(1.1,2.2), 4,0.3,0,2,2)
init_vectors(1.1, C,c(1,2), c(1.1,2.2), 4,0.3,0,2,2)
library(unbalancedTransport)
init_vectors(1.1, C,c(1,2), c(1.1,2.2), 4,0.3,0,2,2)
3^(1/(0.3-1))
-1
3^(1/(0.3-1))-1
(3^(1/(0.3-1))-1)*0.77
init_vectors(1.1, C,c(1,2), c(1.1,2.2), 4,0.3,0,2,2)
init_vectors(1.1, C,c(1,2), c(1.1,2.2), 3,0.3,0,2,2)
init_vectors(1.1, C,c(1,2), c(1.1,2.2), 2,0.3,0,2,2)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
library(unbalancedTransport)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
library(unbalancedTransport)
library(unbalancedTransport)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
library(unbalancedTransport)
library(unbalancedTransport)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
library(unbalancedTransport)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
library(unbalancedTransport)
library(unbalancedTransport)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
library(unbalancedTransport)
library(unbalancedTransport)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
library(unbalancedTransport)
library(unbalancedTransport)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
C
1.5*1.1+3*2.2
2*1.1+4*2.2
0.3*8.25
0.7*11
library(unbalancedTransport)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
library(unbalancedTransport)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
library(unbalancedTransport)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
library(unbalancedTransport)
library(unbalancedTransport)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
library(unbalancedTransport)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
library(unbalancedTransport)
library(unbalancedTransport)
init_vectors(1.1, C,c(0.3,0.7), c(1.1,2.2), 2,0.3,0,2,2)
iterMax <- 1000
# vector of epsilon values
epsvec <- 10^(-3)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
cat("The quadratic cost is used. \n")
nn <- 500
pa1 <- seq(0,0.2, length.out=nn)
pa1
a1 <- rep(1,nn)
a1[1] <- 0
a1[nn] <- 0
a1 <- a1/sum(a1)
a1 <- 0.65*a1
a1
pa2 <- seq(0.9,1, length.out = nn)
a2 <- 0.05-abs(pa2-0.95)
a2[0] <- 0
a2[nn] <- 0
a2 = a2/sum(a2)
a2 <- a2*0.35
a2
p = c(a1,a2)
X = c(pa1, pa2)
qa1 <- seq(0.2,0.4, length.out=nn)
b1 <- seq(0,1,length.out = nn)
b1[0] <- 0
b1[nn] <- 0
b1 <- b1/sum(b1)
b1 <- b1*0.45
qa2 <- seq(0.5,0.9, length.out = nn)
b2 <- sqrt(abs(1-((qa2-0.7)/0.2)^2))
b2[1] <- 0
b2[nn] <- 0
b2 <- b2/sum(b2)
b2 <- 0.55*b2
b2
q <- c(b1, b2)
Y <- c(qa1, qa2)
X
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.05)
demand <- list("KL", q, 0.05)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
print(end_time - start_time)
print(res$TransportPlan)
print(ress$TransportPlan)
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, demandList)
library(unbalancedTransport)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, demandList)
library(unbalancedTransport)
library(unbalancedTransport)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
library(unbalancedTransport)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, demandList)
library(unbalancedTransport)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
plotUOTP(ress$TransportPlan)
library(unbalancedTransport)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
library(unbalancedTransport)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
start_time <- Sys.time()
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plotUOTP(res$TransportPlan)
plot1DTransport(t(res$TransportPlan), supplyList, demandList)
# number of iterations
iterMax <- 10000
# number of iterations
iterMax <- 1000
# number of iterations
iterMax <- 5000
# vector of epsilon values
epsvec <- 10^(-5)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
library(unbalancedTransport)
library(unbalancedTransport)
start_time <- Sys.time()
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plotUOTP(res$TransportPlan)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, demandList)
library(unbalancedTransport)
start_time <- Sys.time()
ress <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
plotUOTP(ress$TransportPlan)
ress
library(unbalancedTransport)
start_time <- Sys.time()
ress <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
# vector of epsilon values
epsvec <- 10^(-3)
start_time <- Sys.time()
ress <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(ress$TransportPlan)
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, demandList)
library(unbalancedTransport)
start_time <- Sys.time()
ress <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, demandList)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, demandList)
# vector of epsilon values
epsvec <- 10^(-7)
start_time <- Sys.time()
ress <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, demandList)
I <- 100
J <- 100
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 5000
# vector of epsilon values
epsvec <- 10^(-7)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
cat("The quadratic cost is used. \n")
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.05)
demand <- list("KL", q, 0.05)
start_time <- Sys.time()
ress <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, demandList)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, demandList)
# vector of epsilon values
epsvec <- 10^(-3)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, demandList)
# vector of epsilon values
epsvec <- 10^(-3)
# number of iterations
iterMax <- 5000
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.05)
demand <- list("KL", q, 0.05)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plotUOTP(ress$TransportPlan)
max(ress$TransportPlan)
p
plot(X,p)
plot(Y,q)
# vector of epsilon values
epsvec <- 10^(seq(-1,-6, length.out = 10))
start_time <- Sys.time()
ress <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, demandList)
plot1DTransport((ress$TransportPlan), supplyList, demandList)
plotUOTP(ress$TransportPlan)
plot1DTransport((ress$TransportPlan), supplyList, demandList)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
# vector of epsilon values
epsvec <- 10^(-6)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
plotUOTP(ress$TransportPlan)
# vector of epsilon values
epsvec <- 10^(-5)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
plotUOTP(ress$TransportPlan)
plot1DTransport((ress$TransportPlan), supplyList, demandList)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
plotUOTP(ress$TransportPlan)
plot1DTransport((ress$TransportPlan), supplyList, demandList)
# vector of epsilon values
epsvec <- 10^(-3)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
plotUOTP(ress$TransportPlan)
plot1DTransport((ress$TransportPlan), supplyList, demandList)
ress <- sinkhornAlgorithmFromCost(C, supply, supply, iterMax, epsvec)
plotUOTP(ress$TransportPlan)
plot1DTransport((ress$TransportPlan), supplyList, supplyList)
plotUOTP(ress$TransportPlan)
ress$dual_f
