library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
sqrt(0)
sqrt(0)
sqrt(0)
sqrt(0)
sqrt(0)
sqrt(0)
sqrt(0)
sqrt(0)
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
ExampleScaling2 <- function(){
xx <- c(0,0,0,3,3.5,4)
xy <- c(0,1,2,1.5,1,0.5)
dx <-c(1/6,1/6,1/6,1/6,1/6,1/6)
dy <- dx
# supply measure
p <- c(2,2,2,0,0,0)
q <- c(0,0,0,1,2,3)
# number of iterations
iterMax <- 10000
# vector of epsilon values
epsvec <- seq(-1,-7, length.out = 20)
epsvec <- 10^(epsvec)
#compute quadrature cost matrix
C <- createCostMatrix(xx,xy)
supply <- list("KL", p, dx, 0.5)
demand <- list("KL", q, dy, 0.5)
# compute and plot the transport plan
res <- scalingAlgorithm(C, supply, demand, iterMax, epsvec)
transportP <- 6*res$transportPlan
print(transportP)
plotUOTP(transportP)
plotTransportByCost(C, transportP, p, q)
}
ExampleScaling2()
ExampleTree1()
#' A second tree metric transport example
#'
#'
#'
#' @export
ExampleTree2 <- function(){
tree <- list(1, c(1,2,1), c(2,3,1), c(2,4,1), c(1,5,1), c(5,6,1), c(5,7,1), c(1,8,10),
c(8,9,1), c(8,10,1))
constructionCost <- rep(2,13)
destructionCost <- rep(2,13)
cat("Mass creation cost: ", constructionCost, "\n")
cat("Mass destruction cost: ", destructionCost, "\n")
supply <- c(0,0,2,0,0,4,0,0,2,0)
demand <- c(0,0,0,0,7,0,0,0,0,1)
cat("Supply: ", supply, "\n")
cat("Demand: ", demand, "\n")
print("The edge weight from 1 to 8 is 10. Every other edge weight is 1.")
transport <- treeAlgorithm(tree, supply, demand , constructionCost,
destructionCost, output = "list")
# Plotting the results
plotTree(tree, tList = transport$transportList, supply = supply, demand = demand)
}
ExampleTree2()
ExampleMonge()
ExampleScaling2()
ExampleScaling1()
ExampleScaling()
#' The Scaling Algorithm Example
#'
#' The examples given in the [paper]
#'
#' @export
#'
ExampleScaling <- function(){
# number of supply and demand points
I <- 1000
J <- 1000
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# Reference Measures
dx <- rep(1,I)/I
dy <- rep(1,J)/J
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 10000
# vector of epsilon values
epsvec <- seq(-1,-7, length.out = 20)
epsvec <- 10^(epsvec)
# supply/demand with discretization and reference measure
supplyList <- list(p, X, dx)
demandList <- list(q, Y, dy)
#compute quadrature cost matrix
C <-  quadCost(X,Y)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, dx, 0.5)
demand <- list("KL", q, dy, 0.5)
# compute and plot the transport plan
res <- scalingAlgorithm(C, supply, demand, iterMax, epsvec)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan)
#compute quadrature cost matrix
C <-  quadCost(X,Y)
# use Total Variation with lambda = 0.05 for supply and demand
supply <- list("TV", p, dx, 0.05)
demand <- list("TV", q, dy, 0.05)
# compute and plot the transport plan
res <- scalingAlgorithm(C, supply, demand, iterMax, epsvec)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan)
#compute Wasserstein-Fisher-Rao cost matrix
C <- wfrCost(X,Y)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, dx, 0.5)
demand <- list("KL", q, dy, 0.5)
# compute and plot the transport plan
res <- scalingAlgorithm(C, supply, demand, 20000, epsvec)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan)
}
ExampleScaling()
#' @param supplyList A supply list containing the divergence to use (either "KL" or "TV"),
#'  a numeric supply vector, the reference measure as numeric vector and the
#'  value for the lambda parameter.
#' @param demandList A demand list containing the divergence to use (either "KL" or "TV"),
#'  a numeric demand vector, the reference measure as numeric vector and the
#'  value for the lambda parameter.
#' @param X Discretization underlying the supply and demand mearsures.
#'
#'
#' @export
plot1DTransport <- function(transportMap,supplyList, demandList, X){
# Number of color intervals
numIntervals <- 50
colors <- rainbow(numIntervals, s = 1, v = 1, start = 0, end = max(1, numIntervals - 1)/numIntervals, alpha = 1, rev = FALSE)
# Plotting the supply and demand measures
plot(1, type = "n", xlab = "", ylab = "", xlim = c(min(c(supplyList[[2]], demandList[[2]])), max(c(supplyList[[2]], demandList[[2]]))), xlim = c(min(c(supplyList[[1]], demandList[[1]])), max(c(supplyList[[1]], demandList[[1]]))), xlab = "Position", ylab = "Mass")
lines(supplyList[[2]], supplyList[[1]], type = "l", lty = 3 , col = "blue")
lines(demandList[[2]], demandList[[1]], type = "l", lty = 3, col = "red")
firstSupp <- supplyList[[2]][1]
firstDem <- demandList[[2]][1]
# Plot the intervals for different colors
for( i in 1:numIntervals){
# Calculating the interval of X
colSuppInter <- rep(1, length(X))
colSuppInter[(i-1)/numIntervals > X | i/numIntervals < X] <- 0
# Restricting the transport map on the interval
subK <- transportMap * colSuppInter
# Adding the color intervals
#lines(supplyList[[2]], t(subK) %*% supplyList[[3]], type = "h", col = colors[i])
#lines(demandList[[2]], subK %*% demandList[[3]], type = "h", col = colors[i])
polygon(c(firstSupp,supplyList[[2]]),c(0,t(subK) %*% supplyList[[3]]), col = colors[i])
polygon(c(firstDem,demandList[[2]]), c(0,subK %*% demandList[[3]]), col = colors[i])
lines(supplyList[[2]], t(subK) %*% supplyList[[3]], type = "l", col = "black")
lines(demandList[[2]], subK %*% demandList[[3]], type = "l", col = "black")
}
lines(supplyList[[2]], t(transportMap) %*% supplyList[[3]], type = "l", col = "red")
lines(demandList[[2]], transportMap %*% demandList[[3]], type = "l", col = "blue")
lines(supplyList[[2]], rep(0, length(supplyList[[2]])), type = "l", col = "black")
}
ExampleScaling()
#' @param supplyList A supply list containing the divergence to use (either "KL" or "TV"),
#'  a numeric supply vector, the reference measure as numeric vector and the
#'  value for the lambda parameter.
#' @param demandList A demand list containing the divergence to use (either "KL" or "TV"),
#'  a numeric demand vector, the reference measure as numeric vector and the
#'  value for the lambda parameter.
#' @param X Discretization underlying the supply and demand mearsures.
#'
#'
#' @export
plot1DTransport <- function(transportMap,supplyList, demandList, X){
# Number of color intervals
numIntervals <- 50
colors <- rainbow(numIntervals, s = 1, v = 1, start = 0, end = max(1, numIntervals - 1)/numIntervals, alpha = 1, rev = FALSE)
# Plotting the supply and demand measures
plot(1, type = "n", xlab = "", ylab = "", xlim = c(min(supplyList[[2]]), max(demandList[[2]])), xlim = c(min(c(supplyList[[1]], demandList[[1]])), max(c(supplyList[[1]], demandList[[1]]))), xlab = "Position", ylab = "Mass")
lines(supplyList[[2]], supplyList[[1]], type = "l", lty = 3 , col = "blue")
lines(demandList[[2]], demandList[[1]], type = "l", lty = 3, col = "red")
firstSupp <- supplyList[[2]][1]
firstDem <- demandList[[2]][1]
# Plot the intervals for different colors
for( i in 1:numIntervals){
# Calculating the interval of X
colSuppInter <- rep(1, length(X))
colSuppInter[(i-1)/numIntervals > X | i/numIntervals < X] <- 0
# Restricting the transport map on the interval
subK <- transportMap * colSuppInter
# Adding the color intervals
#lines(supplyList[[2]], t(subK) %*% supplyList[[3]], type = "h", col = colors[i])
#lines(demandList[[2]], subK %*% demandList[[3]], type = "h", col = colors[i])
polygon(c(firstSupp,supplyList[[2]]),c(0,t(subK) %*% supplyList[[3]]), col = colors[i])
polygon(c(firstDem,demandList[[2]]), c(0,subK %*% demandList[[3]]), col = colors[i])
lines(supplyList[[2]], t(subK) %*% supplyList[[3]], type = "l", col = "black")
lines(demandList[[2]], subK %*% demandList[[3]], type = "l", col = "black")
}
lines(supplyList[[2]], t(transportMap) %*% supplyList[[3]], type = "l", col = "red")
lines(demandList[[2]], transportMap %*% demandList[[3]], type = "l", col = "blue")
lines(supplyList[[2]], rep(0, length(supplyList[[2]])), type = "l", col = "black")
}
#' @param supplyList A supply list containing the divergence to use (either "KL" or "TV"),
#'  a numeric supply vector, the reference measure as numeric vector and the
#'  value for the lambda parameter.
#' @param demandList A demand list containing the divergence to use (either "KL" or "TV"),
#'  a numeric demand vector, the reference measure as numeric vector and the
#'  value for the lambda parameter.
#' @param X Discretization underlying the supply and demand mearsures.
#'
#'
#' @export
plot1DTransport <- function(transportMap,supplyList, demandList, X){
# Number of color intervals
numIntervals <- 50
colors <- rainbow(numIntervals, s = 1, v = 1, start = 0, end = max(1, numIntervals - 1)/numIntervals, alpha = 1, rev = FALSE)
# Plotting the supply and demand measures
plot(supplyList[[2]], supplyList[[1]], type = "l", lty = 3 , col = "blue", xlab = "Position", ylab = "Mass")
lines(demandList[[2]], demandList[[1]], type = "l", lty = 3, col = "red")
firstSupp <- supplyList[[2]][1]
firstDem <- demandList[[2]][1]
# Plot the intervals for different colors
for( i in 1:numIntervals){
# Calculating the interval of X
colSuppInter <- rep(1, length(X))
colSuppInter[(i-1)/numIntervals > X | i/numIntervals < X] <- 0
# Restricting the transport map on the interval
subK <- transportMap * colSuppInter
# Adding the color intervals
#lines(supplyList[[2]], t(subK) %*% supplyList[[3]], type = "h", col = colors[i])
#lines(demandList[[2]], subK %*% demandList[[3]], type = "h", col = colors[i])
polygon(c(firstSupp,supplyList[[2]]),c(0,t(subK) %*% supplyList[[3]]), col = colors[i])
polygon(c(firstDem,demandList[[2]]), c(0,subK %*% demandList[[3]]), col = colors[i])
lines(supplyList[[2]], t(subK) %*% supplyList[[3]], type = "l", col = "black")
lines(demandList[[2]], subK %*% demandList[[3]], type = "l", col = "black")
}
lines(supplyList[[2]], t(transportMap) %*% supplyList[[3]], type = "l", col = "red")
lines(demandList[[2]], transportMap %*% demandList[[3]], type = "l", col = "blue")
lines(supplyList[[2]], rep(0, length(supplyList[[2]])), type = "l", col = "black")
}
ExampleScaling()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling()
# generating random data
mongeMatrix <- genMongeMat(30,30)
supply <- runif(30,0,1)
demand <- runif(30,0,1)
createCost <- runif(1,0,0.2)
destructCost <- runif(1,0,0.3)
# calculating the optimal transport cost and plan
res <- mongeTransport(mongeMatrix, supply, demand, createCost, destructCost)
# plotting the transport plan
plotUOTP(res$transportPlan, res$import, res$export)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
ExampleMonge()
#' The Monge cost matrix example
#'
#' Using the same values as for the scaling algorithm example given in [paper]
#'
#' @export
ExampleMonge <- function(){
print("This function uses the example distributions used in the scaling paper and the quadratic cost matrix.")
# number of supply and demand points
I <- 300
J <- 300
# discretisation of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# reference Measures
dx <- rep(1,I)
dy <- rep(1,J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# supply/demand with discretization and reference measure
supplyList <- list(p, X, dx)
demandList <- list(q, Y, dy)
#compute quadrature cost matrix and check Monge property
C <-  quadCost(X,Y)
checkMongeProperty(C)
print("The cost for mass creation and destruction is set to 1.1")
# compute and plot the transport plan
res <- mongeTransport(C, p, q, 1.1, 1.1)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan, res$import, res$export)
print("The cost for mass creation and destruction is set to 0.2")
# compute and plot the transport plan
res <- mongeTransport(C, p, q, 0.1, 0.1)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan, res$import, res$export)
}
ExampleMonge()
sqrt(0.4)
sqrt(0.4)+0.2
sqrt(0.2)+0.2
0.6*0.6
0.64*0.64
#' Quadratic Cost Matrix
#'
#' Calculating the quadratic cost matrix.
#'
#' @param X A numeric vector.
#' @param Y A numeric vector.
#' @return The quadratic cost matrix.
#' @export
#'
quadCost <- function(X,Y){
C <- matrix(rep(0, length(X)*length(Y)), nrow = length(X))
for(i in 1:length(X)){
for(j in 1:length(Y)){
C[i,j] <- abs(X[i]-Y[j]) #^2
}
}
return(C)
}
ExampleMonge()
#' The Monge cost matrix example
#'
#' Using the same values as for the scaling algorithm example given in [paper]
#'
#' @export
ExampleMonge <- function(){
print("This function uses the example distributions used in the scaling paper and the quadratic cost matrix.")
# number of supply and demand points
I <- 300
J <- 300
# discretisation of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# reference Measures
dx <- rep(1,I)
dy <- rep(1,J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# supply/demand with discretization and reference measure
supplyList <- list(p, X, dx)
demandList <- list(q, Y, dy)
#compute quadrature cost matrix and check Monge property
C <-  quadCost(X,Y)
checkMongeProperty(C)
print("The cost for mass creation and destruction is set to 1.1")
# compute and plot the transport plan
res <- mongeTransport(C, p, q, 1.1, 1.1)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan, res$import, res$export)
print("The cost for mass creation and destruction is set to 0.2")
# compute and plot the transport plan
res <- mongeTransport(C, p, q, 0.1, 0.1)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan, res$import, res$export)
#compute quadrature cost matrix and check Monge property
C <-  quadCost(X,Y)
checkMongeProperty(C)
print("The cost for mass creation and destruction is set to 1.1")
# compute and plot the transport plan
res <- mongeTransport(C, p, q, 1.1, 1.1)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan, res$import, res$export)
}
#' The Monge cost matrix example
#'
#' Using the same values as for the scaling algorithm example given in [paper]
#'
#' @export
ExampleMonge <- function(){
print("This function uses the example distributions used in the scaling paper and the quadratic cost matrix.")
# number of supply and demand points
I <- 300
J <- 300
# discretisation of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# reference Measures
dx <- rep(1,I)
dy <- rep(1,J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# supply/demand with discretization and reference measure
supplyList <- list(p, X, dx)
demandList <- list(q, Y, dy)
#compute quadrature cost matrix and check Monge property
C <-  quadCost(X,Y)
checkMongeProperty(C)
print("The cost for mass creation and destruction is set to 1.1")
# compute and plot the transport plan
res <- mongeTransport(C, p, q, 1.1, 1.1)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan, res$import, res$export)
print("The cost for mass creation and destruction is set to 0.2")
# compute and plot the transport plan
res <- mongeTransport(C, p, q, 0.1, 0.1)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan, res$import, res$export)
#compute quadrature cost matrix and check Monge property
C <-  quadCost(X,Y)
checkMongeProperty(C)
print("The cost for mass creation and destruction is set to 1.1")
# compute and plot the transport plan
res <- mongeTransport(C, p, q, 1.1, 1.1)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan, res$import, res$export)
}
ExampleMonge()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleMonge()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleMonge()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleMonge()
ExampleTree1()
ExampleTree1()
ExampleTree2()
ExampleScaling()
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
0.04383243 *6
0.068747470*6
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling()
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling()
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
