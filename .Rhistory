X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# reference Measures
dx <- rep(1,I)
dy <- rep(1,J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# supply/demand with discretization and reference measure
supplyList <- list(p, X, dx)
demandList <- list(q, Y, dy)
#compute quadrature cost matrix and check Monge property
C <-  quadCost(X,Y)
checkMongeProperty(C)
print("The cost for mass creation and destruction is set to 1.1")
# compute and plot the transport plan
res <- mongeTransport(C, p, q, 1.1, 1.1)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan, res$import, res$export)
print("The cost for mass creation and destruction is set to 0.2")
# compute and plot the transport plan
res <- mongeTransport(C, p, q, 0.1, 0.1)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan, res$import, res$export)
#compute quadrature cost matrix and check Monge property
C <-  quadCost(X,Y)
checkMongeProperty(C)
print("The cost for mass creation and destruction is set to 1.1")
# compute and plot the transport plan
res <- mongeTransport(C, p, q, 1.1, 1.1)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan, res$import, res$export)
}
#' The Monge cost matrix example
#'
#' Using the same values as for the scaling algorithm example given in [paper]
#'
#' @export
ExampleMonge <- function(){
print("This function uses the example distributions used in the scaling paper and the quadratic cost matrix.")
# number of supply and demand points
I <- 300
J <- 300
# discretisation of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# reference Measures
dx <- rep(1,I)
dy <- rep(1,J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# supply/demand with discretization and reference measure
supplyList <- list(p, X, dx)
demandList <- list(q, Y, dy)
#compute quadrature cost matrix and check Monge property
C <-  quadCost(X,Y)
checkMongeProperty(C)
print("The cost for mass creation and destruction is set to 1.1")
# compute and plot the transport plan
res <- mongeTransport(C, p, q, 1.1, 1.1)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan, res$import, res$export)
print("The cost for mass creation and destruction is set to 0.2")
# compute and plot the transport plan
res <- mongeTransport(C, p, q, 0.1, 0.1)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan, res$import, res$export)
#compute quadrature cost matrix and check Monge property
C <-  quadCost(X,Y)
checkMongeProperty(C)
print("The cost for mass creation and destruction is set to 1.1")
# compute and plot the transport plan
res <- mongeTransport(C, p, q, 1.1, 1.1)
plot1DTransport(res$transportPlan, supplyList, demandList, X)
plotUOTP(res$transportPlan, res$import, res$export)
}
ExampleMonge()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleMonge()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleMonge()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleMonge()
ExampleTree1()
ExampleTree1()
ExampleTree2()
ExampleScaling()
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
0.04383243 *6
0.068747470*6
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling()
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling()
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling()
#' supply <- c(0,0,1,2,0,0,0,0,0,0,0,0,0)
#' demand <- c(0,0,0,0,0,1,0,1,0,0,0,1,1)
#'
#' plotTree(tree, supply = supply, demand = demand)
#'
#'
#' tList = list(c(3,6,1), c(4,8,1))
#' plotTree(tree, tList, supply, demand)
#'
#'
plotTree <- function(tree, tList = NULL , supply = NULL, demand = NULL){
if(length(tList) == 0){
tList <- NULL
}
# create a tree data frame
treeDF <- as.data.frame(do.call(rbind, tree[-1]))
colnames(treeDF) <- c("parent", "child", "weight")
treeDF <- treeDF[order(treeDF$parent),]
rootNode <- tree[1]
# initiate a data frame to hold the coordianates for the tree nodes
coordinates <- data.frame(c(rootNode, 0, 0, 100,-100,-1))
colnames(coordinates) <- c("node", "x", "layer", "maxX", "minX", "parent")
# compute all coordinates
coordinates <- nextLayer(treeDF, coordinates, rootNode, -1)
maxLayer <- min(coordinates$layer)
# add the supply to the coordiantes
if(!is.null(supply) & !is.null(demand)){
supDem <- supply-demand
coordinates$supply <- supDem[coordinates$node]
}
# create an empty plot
plot(1, type = "n", xlab = "", ylab = "", xlim = c(-110, 110), ylim = c(maxLayer-1,1), axes = FALSE)
# plot the edges
for(i in 1:nrow(treeDF)){
segments(coordinates[coordinates$node == treeDF[i,]$parent,]$x,
coordinates[coordinates$node == treeDF[i,]$parent,]$layer,
coordinates[coordinates$node == treeDF[i,]$child,]$x,
coordinates[coordinates$node == treeDF[i,]$child,]$layer)
}
# If the supply and demand are not given, plot all nodes in black.
if(is.null(supply) | is.null(demand)){
points(coordinates$x, coordinates$layer,pch = 19 )
# Otherwise plot supply nodes in green and demand nodes in blue.
# The radius of the node indicates the amount of supply / demand: The bigger the node
# the more mass is supplied or demanded.
# Nodes without supply or demand are plotted in black.
}else{
points(coordinates[coordinates$supply  == 0, ]$x, coordinates[coordinates$supply  == 0, ]$layer,
pch = 19 )
points(coordinates[coordinates$supply  > 0, ]$x, coordinates[coordinates$supply  > 0, ]$layer,
pch = 19, cex = abs(coordinates[coordinates$supply > 0, ]$supply),  col = "chartreuse3")
points(coordinates[coordinates$supply  < 0, ]$x, coordinates[coordinates$supply  < 0, ]$layer,
pch = 19, cex = abs(coordinates[coordinates$supply  < 0, ]$supply),  col = "dodgerblue3")
}
# If a transport plan is given, plot the transport paths as arrows
if(!is.null(tList)){
treeDF$tMass <- rep(0, nrow(treeDF))
for(i in 1:length(tList)){
# Finding a path for each transport list entry
pathTo <- unlist(findPath(tList[[i]][1], tList[[i]][2], treeDF))
pathFrom <- NULL
# If the path was not found, the receiving node is not a child of the
# origin node
if(is.null(pathTo)){
# compute the paths from the trees root node to each of the two nodes.
# The path between the two nodes can be computed from these two paths.
pathTo <- unlist(findPath(rootNode, tList[[i]][2], treeDF))
pathFrom <- unlist(findPath(rootNode, tList[[i]][1], treeDF))
while(length(pathFrom) > 1 & length(pathTo) > 1 & pathFrom[2] == pathTo[2]){
pathTo <- pathTo[-1]
pathFrom <- pathFrom[-1]
}
}
if(length(pathTo) > 1){
for(j in 1:(length(pathTo)-1)){
treeDF[(treeDF$parent == pathTo[j] & treeDF$child == pathTo[j+1]),]$tMass =
tList[[i]][3] + treeDF[(treeDF$parent == pathTo[j] & treeDF$child == pathTo[j+1]),]$tMass
}
}
if(length(pathFrom) > 1){
for(j in 1:(length(pathFrom)-1)){
treeDF[(treeDF$parent == pathFrom[j] & treeDF$child == pathFrom[j+1]),]$tMass =
- tList[[i]][3] + treeDF[(treeDF$parent == pathFrom[j] & treeDF$child == pathFrom[j+1]),]$tMass
}
}
}
arrowsDF <- treeDF[treeDF$tMass != 0, ]
# Plotting the arrows.
# The line width indicates the amount of mass moves along that edge.
for(i in 1:nrow(arrowsDF)){
fromX <- coordinates[coordinates$node == arrowsDF[i,]$parent,]$x
fromY <- coordinates[coordinates$node == arrowsDF[i,]$parent,]$layer
toX <- coordinates[coordinates$node == arrowsDF[i,]$child,]$x
toY <- coordinates[coordinates$node == arrowsDF[i,]$child,]$layer
curvedarrow(fromX, fromY, toX, toY, arr.adj = 1,
lwd = abs(arrowsDF[i,]$tMass), code = 1.5+0.5*sign(arrowsDF[i,]$tMass) )
}
}
# Adding the keys to the plot.
text(coordinates$x, coordinates$layer, labels = coordinates$node, pos = 4)
}
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
#' supply <- c(0,0,1,2,0,0,0,0,0,0,0,0,0)
#' demand <- c(0,0,0,0,0,1,0,1,0,0,0,1,1)
#'
#' plotTree(tree, supply = supply, demand = demand)
#'
#'
#' tList = list(c(3,6,1), c(4,8,1))
#' plotTree(tree, tList, supply, demand)
#'
#'
plotTree <- function(tree, tList = NULL , supply = NULL, demand = NULL){
if(length(tList) == 0){
tList <- NULL
}
# create a tree data frame
treeDF <- as.data.frame(do.call(rbind, tree[-1]))
colnames(treeDF) <- c("parent", "child", "weight")
treeDF <- treeDF[order(treeDF$parent),]
rootNode <- tree[1]
# initiate a data frame to hold the coordianates for the tree nodes
coordinates <- data.frame(c(rootNode, 0, 0, 100,-100,-1))
colnames(coordinates) <- c("node", "x", "layer", "maxX", "minX", "parent")
# compute all coordinates
coordinates <- nextLayer(treeDF, coordinates, rootNode, -1)
maxLayer <- min(coordinates$layer)
# add the supply to the coordiantes
if(!is.null(supply) & !is.null(demand)){
supDem <- supply-demand
coordinates$supply <- supDem[coordinates$node]
}
# create an empty plot
plot(1, type = "n", xlab = "", ylab = "", xlim = c(-110, 110), ylim = c(maxLayer-1,1), axes = FALSE)
# plot the edges
for(i in 1:nrow(treeDF)){
segments(coordinates[coordinates$node == treeDF[i,]$parent,]$x,
coordinates[coordinates$node == treeDF[i,]$parent,]$layer,
coordinates[coordinates$node == treeDF[i,]$child,]$x,
coordinates[coordinates$node == treeDF[i,]$child,]$layer)
}
# If the supply and demand are not given, plot all nodes in black.
if(is.null(supply) | is.null(demand)){
points(coordinates$x, coordinates$layer,pch = 19 )
# Otherwise plot supply nodes in green and demand nodes in blue.
# The radius of the node indicates the amount of supply / demand: The bigger the node
# the more mass is supplied or demanded.
# Nodes without supply or demand are plotted in black.
}else{
points(coordinates[coordinates$supply  == 0, ]$x, coordinates[coordinates$supply  == 0, ]$layer,
pch = 19 )
points(coordinates[coordinates$supply  > 0, ]$x, coordinates[coordinates$supply  > 0, ]$layer,
pch = 19, cex = abs(coordinates[coordinates$supply > 0, ]$supply),  col = "chartreuse3")
points(coordinates[coordinates$supply  < 0, ]$x, coordinates[coordinates$supply  < 0, ]$layer,
pch = 19, cex = abs(coordinates[coordinates$supply  < 0, ]$supply),  col = "dodgerblue3")
}
# If a transport plan is given, plot the transport paths as arrows
if(!is.null(tList)){
treeDF$tMass <- rep(0, nrow(treeDF))
for(i in 1:length(tList)){
# Finding a path for each transport list entry
pathTo <- unlist(findPath(tList[[i]][1], tList[[i]][2], treeDF))
pathFrom <- NULL
# If the path was not found, the receiving node is not a child of the
# origin node
if(is.null(pathTo)){
# compute the paths from the trees root node to each of the two nodes.
# The path between the two nodes can be computed from these two paths.
pathTo <- unlist(findPath(rootNode, tList[[i]][2], treeDF))
pathFrom <- unlist(findPath(rootNode, tList[[i]][1], treeDF))
while(length(pathFrom) > 1 & length(pathTo) > 1 & pathFrom[2] == pathTo[2]){
pathTo <- pathTo[-1]
pathFrom <- pathFrom[-1]
}
}
if(length(pathTo) > 1){
for(j in 1:(length(pathTo)-1)){
treeDF[(treeDF$parent == pathTo[j] & treeDF$child == pathTo[j+1]),]$tMass =
tList[[i]][3] + treeDF[(treeDF$parent == pathTo[j] & treeDF$child == pathTo[j+1]),]$tMass
}
}
if(length(pathFrom) > 1){
for(j in 1:(length(pathFrom)-1)){
treeDF[(treeDF$parent == pathFrom[j] & treeDF$child == pathFrom[j+1]),]$tMass =
- tList[[i]][3] + treeDF[(treeDF$parent == pathFrom[j] & treeDF$child == pathFrom[j+1]),]$tMass
}
}
}
arrowsDF <- treeDF[treeDF$tMass != 0, ]
# Plotting the arrows.
# The line width indicates the amount of mass moves along that edge.
for(i in 1:nrow(arrowsDF)){
fromX <- coordinates[coordinates$node == arrowsDF[i,]$parent,]$x
fromY <- coordinates[coordinates$node == arrowsDF[i,]$parent,]$layer
toX <- coordinates[coordinates$node == arrowsDF[i,]$child,]$x
toY <- coordinates[coordinates$node == arrowsDF[i,]$child,]$layer
curvedarrow(fromX, fromY, toX, toY, arr.adj = 1,
lwd = abs(arrowsDF[i,]$tMass), code = 1.5+0.5*sign(arrowsDF[i,]$tMass) )
}
}
# Adding the keys to the plot.
text(coordinates$x, coordinates$layer, labels = coordinates$node, pos = 4)
}
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
#' supply <- c(0,0,1,2,0,0,0,0,0,0,0,0,0)
#' demand <- c(0,0,0,0,0,1,0,1,0,0,0,1,1)
#'
#' plotTree(tree, supply = supply, demand = demand)
#'
#'
#' tList = list(c(3,6,1), c(4,8,1))
#' plotTree(tree, tList, supply, demand)
#'
#'
plotTree <- function(tree, tList = NULL , supply = NULL, demand = NULL){
if(length(tList) == 0){
tList <- NULL
}
# create a tree data frame
treeDF <- as.data.frame(do.call(rbind, tree[-1]))
colnames(treeDF) <- c("parent", "child", "weight")
treeDF <- treeDF[order(treeDF$parent),]
rootNode <- tree[1]
# initiate a data frame to hold the coordianates for the tree nodes
coordinates <- data.frame(c(rootNode, 0, 0, 100,-100,-1))
colnames(coordinates) <- c("node", "x", "layer", "maxX", "minX", "parent")
# compute all coordinates
coordinates <- nextLayer(treeDF, coordinates, rootNode, -1)
maxLayer <- min(coordinates$layer)
coordinates$layer <- coordinates$layer * 100/(-maxLayer)
maxLayer <- min(coordinates$layer)
# add the supply to the coordiantes
if(!is.null(supply) & !is.null(demand)){
supDem <- supply-demand
coordinates$supply <- supDem[coordinates$node]
}
# create an empty plot
plot(1, type = "n", xlab = "", ylab = "", xlim = c(-110, 110), ylim = c(maxLayer-1,1), axes = FALSE)
# plot the edges
for(i in 1:nrow(treeDF)){
segments(coordinates[coordinates$node == treeDF[i,]$parent,]$x,
coordinates[coordinates$node == treeDF[i,]$parent,]$layer,
coordinates[coordinates$node == treeDF[i,]$child,]$x,
coordinates[coordinates$node == treeDF[i,]$child,]$layer)
}
# If the supply and demand are not given, plot all nodes in black.
if(is.null(supply) | is.null(demand)){
points(coordinates$x, coordinates$layer,pch = 19 )
# Otherwise plot supply nodes in green and demand nodes in blue.
# The radius of the node indicates the amount of supply / demand: The bigger the node
# the more mass is supplied or demanded.
# Nodes without supply or demand are plotted in black.
}else{
points(coordinates[coordinates$supply  == 0, ]$x, coordinates[coordinates$supply  == 0, ]$layer,
pch = 19 )
points(coordinates[coordinates$supply  > 0, ]$x, coordinates[coordinates$supply  > 0, ]$layer,
pch = 19, cex = abs(coordinates[coordinates$supply > 0, ]$supply),  col = "chartreuse3")
points(coordinates[coordinates$supply  < 0, ]$x, coordinates[coordinates$supply  < 0, ]$layer,
pch = 19, cex = abs(coordinates[coordinates$supply  < 0, ]$supply),  col = "dodgerblue3")
}
# If a transport plan is given, plot the transport paths as arrows
if(!is.null(tList)){
treeDF$tMass <- rep(0, nrow(treeDF))
for(i in 1:length(tList)){
# Finding a path for each transport list entry
pathTo <- unlist(findPath(tList[[i]][1], tList[[i]][2], treeDF))
pathFrom <- NULL
# If the path was not found, the receiving node is not a child of the
# origin node
if(is.null(pathTo)){
# compute the paths from the trees root node to each of the two nodes.
# The path between the two nodes can be computed from these two paths.
pathTo <- unlist(findPath(rootNode, tList[[i]][2], treeDF))
pathFrom <- unlist(findPath(rootNode, tList[[i]][1], treeDF))
while(length(pathFrom) > 1 & length(pathTo) > 1 & pathFrom[2] == pathTo[2]){
pathTo <- pathTo[-1]
pathFrom <- pathFrom[-1]
}
}
if(length(pathTo) > 1){
for(j in 1:(length(pathTo)-1)){
treeDF[(treeDF$parent == pathTo[j] & treeDF$child == pathTo[j+1]),]$tMass =
tList[[i]][3] + treeDF[(treeDF$parent == pathTo[j] & treeDF$child == pathTo[j+1]),]$tMass
}
}
if(length(pathFrom) > 1){
for(j in 1:(length(pathFrom)-1)){
treeDF[(treeDF$parent == pathFrom[j] & treeDF$child == pathFrom[j+1]),]$tMass =
- tList[[i]][3] + treeDF[(treeDF$parent == pathFrom[j] & treeDF$child == pathFrom[j+1]),]$tMass
}
}
}
arrowsDF <- treeDF[treeDF$tMass != 0, ]
# Plotting the arrows.
# The line width indicates the amount of mass moves along that edge.
for(i in 1:nrow(arrowsDF)){
fromX <- coordinates[coordinates$node == arrowsDF[i,]$parent,]$x
fromY <- coordinates[coordinates$node == arrowsDF[i,]$parent,]$layer
toX <- coordinates[coordinates$node == arrowsDF[i,]$child,]$x
toY <- coordinates[coordinates$node == arrowsDF[i,]$child,]$layer
curvedarrow(c(fromX, fromY), c(toX, toY), arr.adj = 1, arr.pos = 0.5,arr.type = "triangle", curve = 0.2,
lwd = abs(arrowsDF[i,]$tMass), lcol = "red", arr.col = "red")  #, code = 1.5+0.5*sign(arrowsDF[i,]$tMass) )
#curvedarrow(c(x[i],y[i]),c(x[j],y[j]), lwd = 0.5+transportPlan[[i,j]],
#            arr.pos = 0.5, arr.adj = 0.5, arr.type = "triangle",
#            curve = 0.2)
}
}
# Adding the keys to the plot.
text(coordinates$x, coordinates$layer, labels = coordinates$node, pos = 4)
}
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
ExampleTree2()
