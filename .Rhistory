#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
library(unbalancedTransport)
I <- 300
J <- 300
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 6000
# vector of epsilon values
epsvec <- 10^(-3)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
cat("The quadratic cost is used. \n")
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
# compute and plot the transport plan
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
print(res$TransportPlan[1:10,1:10])
plot1DTransport(res$TransportPlan, supplyList, demandList)
# number of iterations
iterMax <- 1
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
print(res$TransportPlan[1:10,1:10])
library(unbalancedTransport)
I <- 300
J <- 300
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 1
# vector of epsilon values
epsvec <- 10^(-3)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
cat("The quadratic cost is used. \n")
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
# compute and plot the transport plan
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
print(res$TransportPlan[1:10,1:10])
I <- 10
J <- 10
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 1
# vector of epsilon values
epsvec <- 10^(-3)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
cat("The quadratic cost is used. \n")
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
print(res$TransportPlan[1:10,1:10])
print(res$TransportPlan)
library(unbalancedTransport)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
print(res$TransportPlan)
library(unbalancedTransport)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
logSumExp(matrix(c(-inf)), nrow = 1)
logSumExp(matrix(c(-inf), nrow = 1))
2/0
logSumExp(matrix(c(-2/0), nrow = 1))
exp(-2/0)
logSumExp(matrix(c(-2/0,unif(100)), nrow = 1))
logSumExp(matrix(c(-2/0,runif(100)), nrow = 1))
logSumExp(matrix(c(-2/0,2/0), nrow = 1))
exp(-inf)
Inf
exp(-Inf)
exp(Inf)
0+Inf
log(Inf)
library(unbalancedTransport)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
library(unbalancedTransport)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
print(res$TransportPlan)
I <- 300
J <- 300
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 1
# vector of epsilon values
epsvec <- 10^(-3)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
cat("The quadratic cost is used. \n")
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
print(res$TransportPlan)
plotUOTP(res$TransportPlan)
plot1DTransport(res$TransportPlan, supplyList, demandList)
library(unbalancedTransport)
library(unbalancedTransport)
I <- 300
J <- 300
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 1000
# vector of epsilon values
epsvec <- 10^(-3)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
cat("The quadratic cost is used. \n")
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
I <- 300
J <- 300
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 1000
# vector of epsilon values
epsvec <- 10^(-3)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
cat("The quadratic cost is used. \n")
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plot1DTransport(res$TransportPlan, supplyList, demandList)
plotUOTP(res$TransportPlan)
# vector of epsilon values
epsvec <- 10^(-7)
I <- 1000
J <- 1000
library(unbalancedTransport)
I <- 1000
J <- 1000
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 1000
# vector of epsilon values
epsvec <- 10^(-7)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
cat("The quadratic cost is used. \n")
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
I <- 200
J <- 200
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 1000
# vector of epsilon values
epsvec <- 10^(-3)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
cat("The quadratic cost is used. \n")
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plot1DTransport(res$TransportPlan, supplyList, demandList)
I <- 1000
J <- 1000
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 1000
# vector of epsilon values
epsvec <- 10^(-3)
cat("Number of iterations: ", iterMax, "\n")
# vector of epsilon values
epsvec <- 10^(-7)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
cat("The quadratic cost is used. \n")
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plot1DTransport(res$TransportPlan, supplyList, demandList)
plotUOTP(res$TransportPlan)
plotUOTP(res$TransportPlan)
# vector of epsilon values
epsvec <- 10^(-3)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
cat("The quadratic cost is used. \n")
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plotUOTP(res$TransportPlan)
plot1DTransport(res$TransportPlan, supplyList, demandList)
# vector of epsilon values
epsvec <- 10^(-4)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plotUOTP(res$TransportPlan)
plot1DTransport(res$TransportPlan, supplyList, demandList)
# vector of epsilon values
epsvec <- 10^(-5)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
library(unbalancedTransport)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
print(res$TransportPlan)
plotUOTP(res$TransportPlan)
plot1DTransport(res$TransportPlan, supplyList, demandList)
# vector of epsilon values
epsvec <- 10^(-4)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plotUOTP(res$TransportPlan)
plot1DTransport(res$TransportPlan, supplyList, demandList)
# vector of epsilon values
epsvec <- 10^(-2)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plotUOTP(res$TransportPlan)
plot1DTransport(res$TransportPlan, supplyList, demandList)
# vector of epsilon values
epsvec <- 10^(-7)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plotUOTP(res$TransportPlan)
plot1DTransport(res$TransportPlan, supplyList, demandList)
max(res$TransportPlan)
# number of iterations
iterMax <- 1
# vector of epsilon values
epsvec <- 10^(-3)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plotUOTP(res$TransportPlan)
# number of iterations
iterMax <- 1
# vector of epsilon values
epsvec <- 10^(-3)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
plotUOTP(res$TransportPlan)
# number of iterations
iterMax <- 1000
# vector of epsilon values
epsvec <- 10^(-1)
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plotUOTP(res$TransportPlan)
plot1DTransport(res$TransportPlan, supplyList, demandList)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("TV", p, 0.5)
demand <- list("TV", q, 0.5)
# number of iterations
iterMax <- 100
start_time <- Sys.time()
res <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plotUOTP(res$TransportPlan)
plot1DTransport(res$TransportPlan, supplyList, demandList)
start_time <- Sys.time()
for(i in 1:1000){
res1[i] <- LSE(amat[i,])
}
end_time <- Sys.time()
ttime <- ttime + end_time - start_time
ttime
res2
res1 <- rep(0, 1000)
ttime1 = 0
ttime2 = 0
ttime = 0
for(j in 1:1000){
start_time <- Sys.time()
res2 <- logSumExp::colLogSumExps(tamat)
end_time <- Sys.time()
ttime1 <- ttime1 +  end_time - start_time
ttime1
start_time <- Sys.time()
for(i in 1:1000){
res1[i] <- LSE(amat[i,])
}
end_time <- Sys.time()
ttime <- ttime + end_time - start_time
ttime
}
a <- runif(100000000)
amat <-matrix(a, ncol = 10000)
tamat <- t(amat)
for(j in 1:1000){
start_time <- Sys.time()
res2 <- logSumExp::colLogSumExps(tamat)
end_time <- Sys.time()
ttime1 <- ttime1 +  end_time - start_time
ttime1
start_time <- Sys.time()
for(i in 1:1000){
res1[i] <- LSE(amat[i,])
}
end_time <- Sys.time()
ttime <- ttime + end_time - start_time
ttime
}
Rcpp::sourceCpp("/home/lars/Dcuments/Master/Masterarbeit/unbalancedTransport/src/AlgorithmSinkhorn.cpp")
Rcpp::sourceCpp("/home/lars/Dcuments/Master/Masterarbeit/unbalancedTransport/src/AlgorithmSinkhorn.cpp")
