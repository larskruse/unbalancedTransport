supply <- list("KL", p, 0.05, X)
demand <- list("KL", q, 0.05, Y)
# compute and plot the transport plan
sinkhorn_divergence(supply, demand, 1e-3, exp = 2)
#' @param method cost method
#' @param exp cost exponent
#' @param p cost parameter
#' @param wfr wfr param
#' @param Cxy cost matrix
#' @param Cxx cost matrix
#' @param Cyy cost matrix
#'
#' @export
#'
sinkhorn_divergence <- function(supplyList, demandList, eps, iterMax = 1000, tol = 1e-3, method = "euclidean", exp = 1, p = 2,  wfr = FALSE,
Cxy = NULL, Cxx = NULL, Cyy = NULL){
lenSup <- length(supplyList)
lenDem <- length(demandList)
X <- supplyList[[lenSup]]
Y <- demandList[[lenDem]]
if(is.null(Cxy)){
Cxy <- costMatrix(X, Y , method, exp, wfr, p)
}
if(is.null(Cxx)){
Cxx <- costMatrix(X, X, method, exp, wfr, p)
}
if(is.null(Cyy)){
Cyy <- costMatrix(Y, Y , method, exp, wfr, p)
}
print(Cxy)
print(Cxx)
print(Cyy)
if(supplyList[[1]] != demandList[[1]]){
print("Please chose the same entropy for supply and demand.")
}
res_xy = sinkhornAlgorithmFromCost(Cxy, supplyList, demandList, iterMax, eps, tol)
res_x = sinkhornAlgorithmFromCost(Cxx, supplyList, supplyList, iterMax, eps, tol)
res_y = sinkhornAlgorithmFromCost(Cyy, demandList, demandList, iterMax, eps, tol)
f_xy = res_xy$dual_f
g_xy = res_xy$dual_g
f_x1 = res_x$dual_f
f_x2 = res_x$dual_g
g_y1 = res_y$dual_f
g_y2 = res_y$dual_g
print("f_xy ...")
print(f_xy)
print(g_xy)
print(f_x1)
print(f_x2)
print(g_y1)
print(g_y2)
cat("\n\n")
if(supplyList[[1]] == "TV"){
print("TV")
print("func")
print(sum(supplyList[[2]] * (f_xy - 0.5*f_x1 - 0.5*f_x2)))
print(sum(demandList[[2]] * (g_xy - 0.5*g_y1 -0.5*g_y2)))
func = sum(supplyList[[2]] * (f_xy - 0.5*f_x1 - 0.5*f_x2)) + sum(demandList[[2]] * (g_xy - 0.5*g_y1 -0.5*g_y2))
print(func)
supxdem = supplyList[[2]] %*% t(demandList[[2]])
supxsup = supplyList[[2]] %*% t(supplyList[[2]])
demxdem = demandList[[2]] %*% t(demandList[[2]])
func = func + sum(eps * supxdem * (1-exp(expC(f_xy,g_xy,Cxy)/eps))) -
0.5*sum(eps * supxsup * (1-exp(expC(f_x1,f_x2,Cxx)/eps))) -
0.5*sum(eps * demxdem * (1-exp(expC(g_y1,g_y2,Cyy)/eps)))
print((1-exp(expC(f_xy,g_xy,Cxy)/eps)))
print(sum(supxdem * (1-exp(expC(f_xy,g_xy,Cxy)/eps))))
print(0.5*sum(supxsup * (1-exp(expC(f_x1,f_x2,Cxx)/eps))))
print(0.5*sum(demxdem * (1-exp(expC(g_y1,g_y2,Cyy)/eps))))
print(eps * sum(supxdem * (1-exp(expC(f_xy,g_xy,Cxy)/eps))))
print(0.5*eps*sum(supxsup * (1-exp(expC(f_x1,f_x2,Cxx)/eps))))
print(0.5*eps*sum(demxdem * (1-exp(expC(g_y1,g_y2,Cyy)/eps))))
print(func)
return(func)
}else if(supplyList[[1]] == "RG" ){
param1 <- supplyList[[3]]
param2 <- supplyList[[4]]
print("outs")
print(-legendre_entropy(0, -f_xy, supplyList[[1]], param1, param2))
print(0.5 * (-legendre_entropy(0, -f_x1, supplyList[[1]], param1, param2)))
print(0.5 * (-legendre_entropy(0, -f_x2, supplyList[[1]], param1, param2)))
print(-legendre_entropy(0, -g_xy, supplyList[[1]], param1, param2))
print(0.5 * (-legendre_entropy(0, -g_y1, supplyList[[1]], param1, param2)))
print(0.5 * (-legendre_entropy(0, -g_y2, supplyList[[1]], param1, param2)))
supxdem = supplyList[[2]] %*% t(demandList[[2]])
supxsup = supplyList[[2]] %*% t(supplyList[[2]])
demxdem = demandList[[2]] %*% t(demandList[[2]])
print("exps")
print(supxdem * (1-exp(expC(f_xy,g_xy,Cxy)/eps)))
print("funcs")
func = sum(supplyList[[2]] * (-legendre_entropy(0, -f_xy, supplyList[[1]], param1, param2)-
0.5 * (-legendre_entropy(0, -f_x1, supplyList[[1]], param1, param2))-
0.5 * (-legendre_entropy(0, -f_x2, supplyList[[1]], param1, param2)))) +
sum(demandList[[2]] * (-legendre_entropy(0, -g_xy, supplyList[[1]], param1, param2) -
0.5 * (-legendre_entropy(0, -g_y1, supplyList[[1]], param1, param2)) -
0.5 * (-legendre_entropy(0, -g_y2, supplyList[[1]], param1, param2))))
print(sum(supplyList[[2]] * (-legendre_entropy(0, -f_xy, supplyList[[1]], param1, param2)
- 0.5 * (-legendre_entropy(0, -f_x1, supplyList[[1]], param1, param2))
- 0.5 * (-legendre_entropy(0, -f_x2, supplyList[[1]], param1, param2)))))
print(sum(demandList[[2]] * (-legendre_entropy(0, -g_xy, supplyList[[1]], param1, param2)
- 0.5 * (-legendre_entropy(0, -g_y1, supplyList[[1]], param1, param2))
- 0.5 * (-legendre_entropy(0, -g_y2, supplyList[[1]], param1, param2)))))
print(func)
print(sum(eps * supxdem * (1-exp(expC(f_xy,g_xy,Cxy)/eps))))
print(0.5*sum(eps * supxsup * (1-exp(expC(f_x1,f_x2,Cxx)/eps))))
print(0.5*sum(eps * demxdem * (1-exp(expC(g_y1,g_y2,Cyy)/eps))))
func = func + sum(eps * supxdem * (1-exp(expC(f_xy,g_xy,Cxy)/eps))) -
0.5*sum(eps * supxsup * (1-exp(expC(f_x1,f_x2,Cxx)/eps))) -
0.5*sum(eps * demxdem * (1-exp(expC(g_y1,g_y2,Cyy)/eps)))
print(func)
return(func)
}else{
param1 <- 0
if(supplyList[[1]] == "Berg"){
supplyList[[1]] <- "Power"
demandList[[1]] <- "Power"
param1 <- 0
}else if(supplyList[[1]] == "Hellinger"){
supplyList[[1]] <- "Power"
demandList[[1]] <- "Power"
param1 <- -1
}else if(supplyList[[1]] == "Power"){
param1 <- supplyList[[4]]
}
outf_xy <- -legendre_entropy(supplyList[[3]], -f_xy, supplyList[[1]], param1) - 0.5*eps*grad_legrende(supplyList[[3]], -f_xy, supplyList[[1]], param1)
outf_xx <- -legendre_entropy(supplyList[[3]], -f_x1, supplyList[[1]], param1) - 0.5*eps*grad_legrende(supplyList[[3]], -f_x1, supplyList[[1]], param1)
outg_xy <- -legendre_entropy(supplyList[[3]], -g_xy, supplyList[[1]], param1) - 0.5*eps*grad_legrende(supplyList[[3]], -g_xy, supplyList[[1]], param1)
outg_yy <- -legendre_entropy(supplyList[[3]], -g_y1, supplyList[[1]], param1) - 0.5*eps*grad_legrende(supplyList[[3]], -g_y1, supplyList[[1]], param1)
print("outs")
print(outf_xy)
print(outf_xx)
print(outf_xy-outf_xx)
print(sum(supplyList[[2]]*(outf_xy-outf_xx)))
print(outg_xy)
print(outg_yy)
print(outg_xy-outg_yy)
print(sum(demandList[[2]]*(outg_xy-outg_yy)))
out <- sum(supplyList[[2]]*(outf_xy-outf_xx)) + sum(demandList[[2]] * (outg_xy - outg_yy))
return(out)
}
}
#' @param iterMax num val
#' @param tol num val
#' @param method cost method
#' @param exp cost exponent
#' @param p cost parameter
#' @param wfr wfr param
#' @param Cxy cost matrix
#'
#' @export
#'
regularizedf_ot <- function(supplyList, demandList, eps, iterMax = 100, tol = 1e-3, method = "euclidean", exp = 1, p = 2,  wfr = FALSE,
Cxy = NULL){
lenSup <- length(supplyList)
lenDem <- length(demandList)
if(is.null(Cxy)){
Cxy <- costMatrix(supplyList[[lenSup]], demandList[[lenDem]], method, exp, wfr, p)
}
print(Cxy[1:10, 1:10])
if(supplyList[[1]] != demandList[[1]]){
print("Please chose the same entropy for supply and demand.")
}
res_xy = sinkhornAlgorithmFromCost(Cxy, supplyList, demandList,
iterMax, eps, tol)
f_xy = res_xy$dual_f
g_xy = res_xy$dual_g
print("solved")
print("f_x, g_y: ")
print(f_xy)
print(g_xy)
if(supplyList[[1]] == "TV"){
print("funcs")
print(sum(supplyList[[2]] * f_xy))
print( sum(demandList[[2]] * g_xy))
func = sum(supplyList[[2]] * f_xy) + sum(demandList[[2]] * g_xy)
print(func)
expFun <- supplyList[[2]] %*% t(demandList[[2]]) * (1-exp(expC(f_xy,g_xy,Cxy)/eps))
print((1-exp(expC(f_xy,g_xy,Cxy)/eps)))
print(sum(eps * expFun))
func = func + sum(eps * expFun)
return(func)
}else if(supplyList[[1]] == "RG" ){
param1 <- supplyList[[3]]
param2 <- supplyList[[4]]
supxdem <- supplyList[[2]] %*% t(demandList[[2]])
print("funcs")
print(sum(supplyList[[2]] * (-legendre_entropy(0, -f_xy, supplyList[[1]], param1, param2))))
print( sum(demandList[[2]] * (-legendre_entropy(0, -g_xy, supplyList[[1]], param1, param2))))
func = sum(supplyList[[2]] * (-legendre_entropy(0, -f_xy, supplyList[[1]], param1, param2)))+
sum(demandList[[2]] * (-legendre_entropy(0, -g_xy, supplyList[[1]], param1, param2)))
print(func)
print(sum(eps * (supxdem * (1-exp(expC(f_xy,g_xy,Cxy)/eps)))))
func = func + sum(eps * (supxdem * (1-exp(expC(f_xy,g_xy,Cxy)/eps))))
print(func)
return(func)
}else{
param1 <- 0
if(supplyList[[1]] == "Berg"){
supplyList[[1]] <- "Power"
demandList[[1]] <- "Power"
param1 <- 0
}else if(supplyList[[1]] == "Hellinger"){
supplyList[[1]] <- "Power"
demandList[[1]] <- "Power"
param1 <- -1
}else if(supplyList[[1]] == "Power"){
param1 <- supplyList[[4]]
}
outf_xy <- -legendre_entropy(supplyList[[3]], -f_xy, supplyList[[1]], param1, 0) - 0.5*eps*grad_legrende(supplyList[[3]], -f_xy, supplyList[[1]], param1)
outg_xy <- -legendre_entropy(supplyList[[3]], -g_xy, supplyList[[1]], param1, 0) - 0.5*eps*grad_legrende(supplyList[[3]], -g_xy, supplyList[[1]], param1)
print("pre outs")
print(legendre_entropy(supplyList[[3]], -f_xy, supplyList[[1]], param1, 0))
print(grad_legrende(supplyList[[3]], -f_xy, supplyList[[1]], param1))
print(legendre_entropy(supplyList[[3]], -g_xy, supplyList[[1]], param1, 0))
print(grad_legrende(supplyList[[3]], -g_xy, supplyList[[1]], param1))
print("outs")
print(outf_xy)
print(outg_xy)
print("funcs")
print(sum(supplyList[[2]] * outf_xy))
print(sum(supplyList[[2]] * outf_xy)+ sum(demandList[[2]] * outg_xy))
print(sum(supplyList[[2]] * outf_xy)+ sum(demandList[[2]] * outg_xy)+ eps*(sum(supplyList[[2]]) * sum(demandList[[2]])))
print(eps*(sum(supplyList[[2]]) + sum(demandList[[2]])))
res = sum(supplyList[[2]] * outf_xy) + sum(demandList[[2]] * outg_xy) + eps*(sum(supplyList[[2]]) * sum(demandList[[2]]))
return(res)
}
}
supply <- list("KL", p, 0.05, X)
demand <- list("KL", q, 0.05, Y)
# compute and plot the transport plan
sinkhorn_divergence(supply, demand, 1e-3, exp = 2)
# compute and plot the transport plan
sinkhorn_divergence(supply, demand, 1e-3, exp = 2)
regularizedf_ot(supply, demand, 1e-3, exp = 2)
#' @param demandList A demand list containing the divergence to use (either "KL" or "TV"),
#'  a numeric demand vector, the reference measure as numeric vector and the
#'  value for the lambda parameter.
#' @param maxIteration A numeric value for the maximum number of iterations.
#' The default value is 20000.
#' @param eps vector of epsilon values to use
#' @param tol tolerance for break
#'
#' @export
#'
sinkhornAlgorithmFromCost <- function(costMatrix, supplyList, demandList,
maxIteration, eps, tol = 1e-3){
supplyReg <- 0
demandReg <- 0
supplyAlpha <- 0
supplyBeta <- 0
demandAlpha <- 0
demandBeta <- 0
if(supplyList[[1]] == "KL"){
Div1 <- 1
supplyReg <- supplyList[[3]]
}else if(supplyList[[1]] == "TV"){
Div1 <- 2
supplyReg <- supplyList[[3]]
}else if(supplyList[[1]] == "RG"){
Div1 <- 3
supplyAlpha <- supplyList[[3]]
supplyBeta <- supplyList[[4]]
if(supplyAlpha < 0 || supplyBeta < supplyAlpha){
stop("0 <= Alpha <= Beta")
}
}else if(supplyList[[1]] == "Berg"){
Div1 <- 4
supplyReg <- supplyList[[3]]
supplyAlpha <- 0
}else if(supplyList[[1]] == "Hellinger"){
Div1 <- 4
supplyReg <- supplyList[[3]]
supplyAlpha <- -1
}else if(supplyList[[1]] == "Power"){
Div1 <- 4
supplyReg <- supplyList[[3]]
supplyAlpha <- supplyList[[4]]
}else{
stop("Please supply a divergence")
}
if(demandList[[1]] == "KL"){
Div2 <- 1
demandReg <- demandList[[3]]
}else if(demandList[[1]] == "TV"){
Div2 <- 2
demandReg <- demandList[[3]]
}else if(demandList[[1]] == "RG"){
Div2 <- 3
demandAlpha <- demandList[[3]]
demandBeta <- demandList[[4]]
if(demandAlpha < 0 || demandBeta < demandAlpha){
stop("0 <= Alpha <= Beta")
}
}else if (demandList[[1]] == "Berg"){
Div2 <- 4
demandReg <- demandList[[3]]
demandAlpha <- 0
}else if(demandList[[1]] == "Hellinger"){
Div2 <- 4
demandReg <- demandList[[3]]
demandAlpha <- -1
}else if(demandList[[1]] == "Power"){
Div2 <- 4
demandReg <- demandList[[3]]
demandAlpha <- demandList[[4]]
}else{
stop("Please supply a divergence")
}
supply <- supplyList[[2]]
demand <- demandList[[2]]
print(supplyAlpha)
print(demandAlpha)
res <- Sinkhorn_Rcpp(costMatrix, supply, demand, supplyReg, supplyAlpha,
supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
Div2, maxIteration, eps, tol)
TransportPlan <- res$TransportPlan*(supply %*% t(demand))
returnList <- list("TransportPlan" = TransportPlan, "dual_f" = res$dual_f, "dual_g" =  res$dual_g)
# res2 <- Sinkhorn_Eigen_Rcpp(costMatrix, supply, demand, supplyReg, supplyAlpha,
#                             supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
#                             Div2, maxIteration, eps)
#
# TransportPlan2 <- res2$TransportPlan*supply %*% t(demand)
#
# returnList2 <- list("TransportPlan" = TransportPlan2, "dual_f" = res2$dual_f, "dual_g" =  res2$dual_g)
return(returnList)
}
ress <- sinkhornAlgorithmFromCost(costMatrix(X,X, exp = 2), supply, supply, iterMax, epsvec)
ress
plotUOTP(ress$TransportPlan)
supply <- list("TV", p, 0.05, X)
demand <- list("TV", q, 0.05, Y)
ress <- sinkhornAlgorithmFromCost(costMatrix(X,X, exp = 2), supply, supply, iterMax, epsvec)
ress
plotUOTP(ress$TransportPlan)
nn <- 250
nn <- 250
pa1 <- seq(0,0.2, length.out=nn)
pa1
a1 <- rep(1,nn)
a1[1] <- 0
a1[nn] <- 0
a1 <- a1/sum(a1)
a1 <- 0.65*a1
a1
pa2 <- seq(0.9,1, length.out = nn)
a2 <- 0.05-abs(pa2-0.95)
a2[0] <- 0
a2[nn] <- 0
a2 = a2/sum(a2)
a2 <- a2*0.35
a2
p = c(a1,a2)
X = c(pa1, pa2)
qa1 <- seq(0.2,0.4, length.out=nn)
b1 <- seq(0,1,length.out = nn)
b1[0] <- 0
b1[nn] <- 0
b1 <- b1/sum(b1)
b1 <- b1*0.45
qa2 <- seq(0.5,0.9, length.out = nn)
b2 <- sqrt(abs(1-((qa2-0.7)/0.2)^2))
b2[1] <- 0
b2[nn] <- 0
b2 <- b2/sum(b2)
b2 <- 0.55*b2
b2
q <- c(b1, b2)
Y <- c(qa1, qa2)
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
C
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("RG", p, 0.7, 1.3, X)
demand <- list("RG", q, 0.7, 1.3, Y)
supply <- list("KL", p, 0.05, X)
demand <- list("KL", q, 0.05, Y)
ress <- sinkhornAlgorithmFromCost(costMatrix(X,X, exp = 2), supply, supply, iterMax, epsvec)
plotUOTP(ress$TransportPlan)
ress <- sinkhornAlgorithmFromCost(costMatrix(X,Y, exp = 2), supply, demand, iterMax, epsvec)
plotUOTP(ress$TransportPlan)
ress <- sinkhornAlgorithmFromCost(costMatrix(X,Y, exp = 2), supply, demand, iterMax, epsvec, tol = 1e-5)
plotUOTP(ress$TransportPlan)
I <- 300
J <- 300
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 1000
# vector of epsilon values
epsvec <- 10^(-3)
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
C
supply <- list("KL", p, 0.05, X)
demand <- list("KL", q, 0.05, Y)
ress <- sinkhornAlgorithmFromCost(costMatrix(X,Y, exp = 2), supply, demand, iterMax, epsvec, tol = 1e-5)
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, supplyList)
ress <- sinkhornAlgorithmFromCost(costMatrix(X,Y, exp = 2), supply, demand,
iterMax, epsvec, tol = 1e-1)
plot1DTransport(t(ress$TransportPlan), supplyList, supplyList)
ress <- sinkhornAlgorithmFromCost(costMatrix(X,Y, exp = 2), supply, demand,
iterMax, epsvec, tol = 1e-8)
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, supplyList)
supply <- list("RG", p, 0.7, 1.3, X)
demand <- list("RG", q, 0.7, 1.3, Y)
ress <- sinkhornAlgorithmFromCost(costMatrix(X,Y, exp = 2), supply, demand,
iterMax, epsvec, tol = 1e-8)
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, supplyList)
ress <- sinkhornAlgorithmFromCost(costMatrix(X,Y, exp = 2), supply, demand,
iterMax, epsvec, tol = 1e-3)
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, supplyList)
I <- 1000
J <- 1000
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 1000
# vector of epsilon values
epsvec <- 10^(-3)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand. \n")
cat("The quadratic cost is used. \n")
nn <- 250
I <- 1000
J <- 1000
# Discretization of [0,1]
X <- seq(0,1,length.out = I)
Y <- seq(0,1,length.out = J)
# supply measure
p <- sapply(X, fp)
p[1] <- 0
p[I] <- 0
# demand measure
q <- sapply(Y, fq)
q <- q*sum(p)/sum(q)
# number of iterations
iterMax <- 1000
# vector of epsilon values
epsvec <- 10^(-3)
cat("Number of iterations: ", iterMax, "\n")
# number of iterations
iterMax <- 10000
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
C
supply <- list("KL", p, 0.05, X)
demand <- list("KL", q, 0.05, Y)
ress <- sinkhornAlgorithmFromCost(costMatrix(X,Y, exp = 2), supply, demand,
iterMax, epsvec, tol = 1e-3)
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, supplyList)
supply <- list("TV", p, 0.05, X)
demand <- list("TV", q, 0.05, Y)
ress <- sinkhornAlgorithmFromCost(costMatrix(X,Y, exp = 2), supply, demand,
iterMax, epsvec, tol = 1e-3)
plotUOTP(ress$TransportPlan)
plot1DTransport(t(ress$TransportPlan), supplyList, supplyList)
plot1DTransport((ress$TransportPlan), supplyList, supplyList)
plot(X,p)
plot(Y,q)
plotUOTP(ress$TransportPlan)
supply <- list("TV", p, 0.05, X)
demand <- list("TV", q, 0.05, Y)
ress <- sinkhornAlgorithmFromCost(costMatrix(X,Y, exp = 2), supply, demand,
iterMax, epsvec, tol = 1e-3)
ress <- sinkhornAlgorithmFromCost(costMatrix(X,Y, exp = 2), supply, demand,
iterMax, epsvec, tol = 1e-5)
plotUOTP(ress$TransportPlan)
plot1DTransport((ress$TransportPlan), supplyList, supplyList)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("RG", p, 0.7, 1.3, X)
demand <- list("RG", q, 0.7, 1.3, Y)
ress <- sinkhornAlgorithmFromCost(costMatrix(X,Y, exp = 2), supply, demand,
iterMax, epsvec, tol = 1e-5)
plotUOTP(ress$TransportPlan)
plot1DTransport((ress$TransportPlan), supplyList, supplyList)
ress <- scalingAlgorithmFromCost(costMatrix(X,X, exp = 2), supply, supply, iterMax, epsvec)
plotUOTP(ress$TransportPlan)
ress <- scalingAlgorithmFromCost(costMatrix(X,Y, exp = 2), supply, demand, iterMax, epsvec)
plotUOTP(ress$TransportPlan)
plot1DTransport((ress$TransportPlan), supplyList, supplyList)
library(unbalancedTransport)
