g_yy = res_y$dual_g
res <- sum(supplyList[[2]] * (legendre_entropy(supplyList[[3]], -f_xx, supplyList[[1]], param1, param2) + eps * grad_legrende(supplyList[[3]], -f_xx, supplyList[[1]], param1, param2)
- legendre_entropy(supplyList[[3]], -f_xy, supplyList[[1]], param1, param2) + eps * grad_legrende(supplyList[[3]], -f_xy,supplyList[[1]], param1, param2) )) +
sum(demandList[[2]] *(legendre_entropy(supplyList[[3]], -g_yy, supplyList[[1]], param1, param2) + eps * grad_legrende(supplyList[[3]], -g_yy,supplyList[[1]], param1, param2)
- legendre_entropy(supplyList[[3]], -g_xy, supplyList[[1]], param1, param2) + eps * grad_legrende(supplyList[[3]], -g_xy, supplyList[[1]], param1, param2)))
return(res)
}
# compute and plot the transport plan
sinkhorn_divergence(supply, demand, 1e-3, exp = 2)
regularizedf_ot(supply, demand, 1e-3, exp = 2)
hausdorff_divergence(supply, demand, 1e-3, exp = 2)
#' @param demandList A demand list containing the divergence to use (either "KL" or "TV"),
#'  a numeric demand vector, the reference measure as numeric vector and the
#'  value for the lambda parameter.
#' @param maxIteration A numeric value for the maximum number of iterations.
#' The default value is 20000.
#' @param eps vector of epsilon values to use
#' @param tol tolerance for break
#'
#' @export
#'
sinkhornAlgorithmFromCost <- function(costMatrix, supplyList, demandList,
maxIteration, eps, tol = 1e-8){
supplyReg <- 0
demandReg <- 0
supplyAlpha <- 0
supplyBeta <- 0
demandAlpha <- 0
demandBeta <- 0
if(supplyList[[1]] == "KL"){
Div1 <- 1
supplyReg <- supplyList[[3]]
}else if(supplyList[[1]] == "TV"){
Div1 <- 2
supplyReg <- supplyList[[3]]
}else if(supplyList[[1]] == "RG"){
Div1 <- 3
supplyAlpha <- supplyList[[3]]
supplyBeta <- supplyList[[4]]
if(supplyAlpha < 0 || supplyBeta < supplyAlpha){
stop("0 <= Alpha <= Beta")
}
}else if(supplyList[[1]] == "Berg"){
Div1 <- 4
supplyReg <- supplyList[[3]]
supplyAlpha <- 0
}else if(supplyList[[1]] == "Hellinger"){
Div1 <- 4
supplyReg <- supplyList[[3]]
supplyAlpha <- -1
}else if(supplyList[[1]] == "Power"){
Div1 <- 4
supplyReg <- supplyList[[3]]
supplyAlpha <- supplyList[[4]]
}else{
stop("Please supply a divergence")
}
if(demandList[[1]] == "KL"){
Div2 <- 1
demandReg <- demandList[[3]]
}else if(demandList[[1]] == "TV"){
Div2 <- 2
demandReg <- demandList[[3]]
}else if(demandList[[1]] == "RG"){
Div2 <- 3
demandAlpha <- demandList[[3]]
demandBeta <- demandList[[4]]
if(demandAlpha < 0 || demandBeta < demandAlpha){
stop("0 <= Alpha <= Beta")
}
}else if (demandList[[1]] == "Berg"){
Div2 <- 4
demandReg <- demandList[[3]]
demandAlpha <- 0
}else if(demandList[[1]] == "Hellinger"){
Div2 <- 4
demandReg <- demandList[[3]]
demandAlpha <- -1
}else if(demandList[[1]] == "Power"){
Div2 <- 4
demandReg <- demandList[[3]]
demandAlpha <- demandList[[4]]
}else{
stop("Please supply a divergence")
}
supply <- supplyList[[2]]
demand <- demandList[[2]]
print(supplyReg)
print(demandReg)
print(supplyAlpha)
print(supplyBeta)
print(demandAlpha)
print(demandBeta)
print(Div1)
print(Div2)
print(maxIteration)
print(eps)
print(tol)
res <- Sinkhorn_Rcpp(costMatrix, supply, demand, supplyReg, supplyAlpha,
supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
Div2, maxIteration, eps, tol)
TransportPlan <- res$TransportPlan*(supply %*% t(demand))
returnList <- list("TransportPlan" = TransportPlan, "dual_f" = res$dual_f, "dual_g" =  res$dual_g)
# res2 <- Sinkhorn_Eigen_Rcpp(costMatrix, supply, demand, supplyReg, supplyAlpha,
#                             supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
#                             Div2, maxIteration, eps)
#
# TransportPlan2 <- res2$TransportPlan*supply %*% t(demand)
#
# returnList2 <- list("TransportPlan" = TransportPlan2, "dual_f" = res2$dual_f, "dual_g" =  res2$dual_g)
return(returnList)
}
#' @param demandList A demand list containing the divergence to use (either "KL" or "TV"),
#'  a numeric demand vector, the reference measure as numeric vector and the
#'  value for the lambda parameter.
#' @param maxIteration A numeric value for the maximum number of iterations.
#' The default value is 20000.
#' @param eps vector of epsilon values to use
#' @param tol tolerance for break
#'
#' @export
#'
sinkhornAlgorithmFromCost <- function(costMatrix, supplyList, demandList,
maxIteration, eps, tol = 1e-8){
supplyReg <- 0
demandReg <- 0
supplyAlpha <- 0
supplyBeta <- 0
demandAlpha <- 0
demandBeta <- 0
if(supplyList[[1]] == "KL"){
Div1 <- 1
supplyReg <- supplyList[[3]]
}else if(supplyList[[1]] == "TV"){
Div1 <- 2
supplyReg <- supplyList[[3]]
}else if(supplyList[[1]] == "RG"){
Div1 <- 3
supplyAlpha <- supplyList[[3]]
supplyBeta <- supplyList[[4]]
if(supplyAlpha < 0 || supplyBeta < supplyAlpha){
stop("0 <= Alpha <= Beta")
}
}else if(supplyList[[1]] == "Berg"){
Div1 <- 4
supplyReg <- supplyList[[3]]
supplyAlpha <- 0
}else if(supplyList[[1]] == "Hellinger"){
Div1 <- 4
supplyReg <- supplyList[[3]]
supplyAlpha <- -1
}else if(supplyList[[1]] == "Power"){
Div1 <- 4
supplyReg <- supplyList[[3]]
supplyAlpha <- supplyList[[4]]
}else{
stop("Please supply a divergence")
}
if(demandList[[1]] == "KL"){
Div2 <- 1
demandReg <- demandList[[3]]
}else if(demandList[[1]] == "TV"){
Div2 <- 2
demandReg <- demandList[[3]]
}else if(demandList[[1]] == "RG"){
Div2 <- 3
demandAlpha <- demandList[[3]]
demandBeta <- demandList[[4]]
if(demandAlpha < 0 || demandBeta < demandAlpha){
stop("0 <= Alpha <= Beta")
}
}else if (demandList[[1]] == "Berg"){
Div2 <- 4
demandReg <- demandList[[3]]
demandAlpha <- 0
}else if(demandList[[1]] == "Hellinger"){
Div2 <- 4
demandReg <- demandList[[3]]
demandAlpha <- -1
}else if(demandList[[1]] == "Power"){
Div2 <- 4
demandReg <- demandList[[3]]
demandAlpha <- demandList[[4]]
}else{
stop("Please supply a divergence")
}
supply <- supplyList[[2]]
demand <- demandList[[2]]
print(supplyReg)
print(demandReg)
print(supplyAlpha)
print(supplyBeta)
print(demandAlpha)
print(demandBeta)
print(Div1)
print(Div2)
print(maxIteration)
print(eps)
print(tol)
res <- Sinkhorn_Rcpp(costMatrix, supply, demand, supplyReg, supplyAlpha,
supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
Div2, maxIteration, eps, tol)
TransportPlan <- res$TransportPlan*(supply %*% t(demand))
returnList <- list("TransportPlan" = TransportPlan, "dual_f" = res$dual_f, "dual_g" =  res$dual_g)
# res2 <- Sinkhorn_Eigen_Rcpp(costMatrix, supply, demand, supplyReg, supplyAlpha,
#                             supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
#                             Div2, maxIteration, eps)
#
# TransportPlan2 <- res2$TransportPlan*supply %*% t(demand)
#
# returnList2 <- list("TransportPlan" = TransportPlan2, "dual_f" = res2$dual_f, "dual_g" =  res2$dual_g)
return(returnList)
}
hausdorff_divergence(supply, demand, 1e-3, exp = 2)
#' @param demandList A demand list containing the divergence to use (either "KL" or "TV"),
#'  a numeric demand vector, the reference measure as numeric vector and the
#'  value for the lambda parameter.
#' @param maxIteration A numeric value for the maximum number of iterations.
#' The default value is 20000.
#' @param eps vector of epsilon values to use
#' @param tol tolerance for break
#'
#' @export
#'
sinkhornAlgorithmFromCost <- function(costMatrix, supplyList, demandList,
maxIteration, eps, tol = 1e-8){
supplyReg <- 0
demandReg <- 0
supplyAlpha <- 0
supplyBeta <- 0
demandAlpha <- 0
demandBeta <- 0
if(supplyList[[1]] == "KL"){
Div1 <- 1
supplyReg <- supplyList[[3]]
}else if(supplyList[[1]] == "TV"){
Div1 <- 2
supplyReg <- supplyList[[3]]
}else if(supplyList[[1]] == "RG"){
Div1 <- 3
supplyAlpha <- supplyList[[3]]
supplyBeta <- supplyList[[4]]
if(supplyAlpha < 0 || supplyBeta < supplyAlpha){
stop("0 <= Alpha <= Beta")
}
}else if(supplyList[[1]] == "Berg"){
Div1 <- 4
supplyReg <- supplyList[[3]]
supplyAlpha <- 0
}else if(supplyList[[1]] == "Hellinger"){
Div1 <- 4
supplyReg <- supplyList[[3]]
supplyAlpha <- -1
}else if(supplyList[[1]] == "Power"){
Div1 <- 4
supplyReg <- supplyList[[3]]
supplyAlpha <- supplyList[[4]]
}else{
stop("Please supply a divergence")
}
if(demandList[[1]] == "KL"){
Div2 <- 1
demandReg <- demandList[[3]]
}else if(demandList[[1]] == "TV"){
Div2 <- 2
demandReg <- demandList[[3]]
}else if(demandList[[1]] == "RG"){
Div2 <- 3
demandAlpha <- demandList[[3]]
demandBeta <- demandList[[4]]
if(demandAlpha < 0 || demandBeta < demandAlpha){
stop("0 <= Alpha <= Beta")
}
}else if (demandList[[1]] == "Berg"){
Div2 <- 4
demandReg <- demandList[[3]]
demandAlpha <- 0
}else if(demandList[[1]] == "Hellinger"){
Div2 <- 4
demandReg <- demandList[[3]]
demandAlpha <- -1
}else if(demandList[[1]] == "Power"){
Div2 <- 4
demandReg <- demandList[[3]]
demandAlpha <- demandList[[4]]
}else{
stop("Please supply a divergence")
}
supply <- supplyList[[2]]
demand <- demandList[[2]]
print(supplyAlpha)
print(demandAlpha)
res <- Sinkhorn_Rcpp(costMatrix, supply, demand, supplyReg, supplyAlpha,
supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
Div2, maxIteration, eps, tol)
TransportPlan <- res$TransportPlan*(supply %*% t(demand))
returnList <- list("TransportPlan" = TransportPlan, "dual_f" = res$dual_f, "dual_g" =  res$dual_g)
# res2 <- Sinkhorn_Eigen_Rcpp(costMatrix, supply, demand, supplyReg, supplyAlpha,
#                             supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
#                             Div2, maxIteration, eps)
#
# TransportPlan2 <- res2$TransportPlan*supply %*% t(demand)
#
# returnList2 <- list("TransportPlan" = TransportPlan2, "dual_f" = res2$dual_f, "dual_g" =  res2$dual_g)
return(returnList)
}
hausdorff_divergence(supply, demand, 1e-3, exp = 2)
hausdorff_divergence <- function(supplyList, demandList, eps, iterMax = 100, tol = 1e-3, method = "euclidean", exp = 1, p = 2,  wfr = FALSE,
Cxx = NULL, Cyy = NULL){
lenSup <- length(supplyList)
lenDem <- length(demandList)
if(is.null(Cxx)){
Cxx <- costMatrix(supplyList[[lenSup]], supplyList[[lenSup]], method, exp, wfr, p)
}
if(is.null(Cyy)){
Cyy <- costMatrix(demandList[[lenDem]], supplyList[[lenDem]], method, exp, wfr, p)
}
if(supplyList[[1]] != demandList[[1]]){
print("Please chose the same entropy for supply and demand.")
}
param1 <- 0
param2 <- 0
res_x = sinkhornAlgorithmFromCost(Cxx, supplyList, supplyList, iterMax, eps, tol)
res_y = sinkhornAlgorithmFromCost(Cyy, demandList, demandList, iterMax, eps, tol)
f_xx = res_x$dual_f
g_xy = res_x$dual_g
f_xy = res_y$dual_f
g_yy = res_y$dual_g
if(supplyList[[1]] == "Berg"){
supplyList[[1]] <- "Power"
demandList[[1]] <- "Power"
param1 <- 0
}else if(supplyList[[1]] == "Hellinger"){
supplyList[[1]] <- "Power"
demandList[[1]] <- "Power"
param1 <- -1
}else if(supplyList[[1]] == "Power"){
param1 <- supplyList[[4]]
}else if(supplyList[[1]] == "RG"){
param1 <- supplyList[[3]]
param2 <- supplyList[[4]]
}
res <- sum(supplyList[[2]] * (legendre_entropy(supplyList[[3]], -f_xx, supplyList[[1]], param1, param2) + eps * grad_legrende(supplyList[[3]], -f_xx, supplyList[[1]], param1, param2)
- legendre_entropy(supplyList[[3]], -f_xy, supplyList[[1]], param1, param2) + eps * grad_legrende(supplyList[[3]], -f_xy,supplyList[[1]], param1, param2) )) +
sum(demandList[[2]] *(legendre_entropy(supplyList[[3]], -g_yy, supplyList[[1]], param1, param2) + eps * grad_legrende(supplyList[[3]], -g_yy,supplyList[[1]], param1, param2)
- legendre_entropy(supplyList[[3]], -g_xy, supplyList[[1]], param1, param2) + eps * grad_legrende(supplyList[[3]], -g_xy, supplyList[[1]], param1, param2)))
return(res)
}
hausdorff_divergence <- function(supplyList, demandList, eps, iterMax = 100, tol = 1e-3, method = "euclidean", exp = 1, p = 2,  wfr = FALSE,
Cxx = NULL, Cyy = NULL){
lenSup <- length(supplyList)
lenDem <- length(demandList)
if(is.null(Cxx)){
Cxx <- costMatrix(supplyList[[lenSup]], supplyList[[lenSup]], method, exp, wfr, p)
}
if(is.null(Cyy)){
Cyy <- costMatrix(demandList[[lenDem]], supplyList[[lenDem]], method, exp, wfr, p)
}
if(supplyList[[1]] != demandList[[1]]){
print("Please chose the same entropy for supply and demand.")
}
param1 <- 0
param2 <- 0
res_x = sinkhornAlgorithmFromCost(Cxx, supplyList, supplyList, iterMax, eps, tol)
res_y = sinkhornAlgorithmFromCost(Cyy, demandList, demandList, iterMax, eps, tol)
f_xx = res_x$dual_f
g_xy = res_x$dual_g
f_xy = res_y$dual_f
g_yy = res_y$dual_g
if(supplyList[[1]] == "Berg"){
supplyList[[1]] <- "Power"
demandList[[1]] <- "Power"
param1 <- 0
}else if(supplyList[[1]] == "Hellinger"){
supplyList[[1]] <- "Power"
demandList[[1]] <- "Power"
param1 <- -1
}else if(supplyList[[1]] == "Power"){
param1 <- supplyList[[4]]
}else if(supplyList[[1]] == "RG"){
param1 <- supplyList[[3]]
param2 <- supplyList[[4]]
}
res <- sum(supplyList[[2]] * (legendre_entropy(supplyList[[3]], -f_xx, supplyList[[1]], param1, param2) + eps * grad_legrende(supplyList[[3]], -f_xx, supplyList[[1]], param1, param2)
- legendre_entropy(supplyList[[3]], -f_xy, supplyList[[1]], param1, param2) + eps * grad_legrende(supplyList[[3]], -f_xy,supplyList[[1]], param1, param2) )) +
sum(demandList[[2]] *(legendre_entropy(supplyList[[3]], -g_yy, supplyList[[1]], param1, param2) + eps * grad_legrende(supplyList[[3]], -g_yy,supplyList[[1]], param1, param2)
- legendre_entropy(supplyList[[3]], -g_xy, supplyList[[1]], param1, param2) + eps * grad_legrende(supplyList[[3]], -g_xy, supplyList[[1]], param1, param2)))
return(res)
}
hausdorff_divergence(supply, demand, 1e-3, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("Berg", p, 0.5, X)
demand <- list("Berg", q, 0.5, Y)
# compute and plot the transport plan
sinkhorn_divergence(supply, demand, 1e-3, exp = 2)
regularizedf_ot(supply, demand, 1e-3, exp = 2)
hausdorff_divergence(supply, demand, 1e-3, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("Power", p, 0.5, 0.4, X)
demand <- list("Power", q, 0.5, 0.4, Y)
# compute and plot the transport plan
sinkhorn_divergence(supply, demand, 1e-3, exp = 2)
hausdorff_divergence(supply, demand, 1e-3, exp = 2)
regularizedf_ot(supply, demand, 1e-3, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.5, X)
demand <- list("KL", q, 0.5, Y)
# compute and plot the transport plan
sinkhorn_divergence(supply, demand, 1e-3, exp = 2)
hausdorff_divergence(supply, demand, 1e-3, exp = 2)
regularizedf_ot(supply, demand, 1e-3, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("TV", p, 0.5, X)
demand <- list("TV", q, 0.5, Y)
# compute and plot the transport plan
sinkhorn_divergence(supply, demand, 1e-3, exp = 2)
hausdorff_divergence(supply, demand, 1e-3, exp = 2)
regularizedf_ot(supply, demand, 1e-3, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("RG", p, 0.5, 0.3, 1.7, X)
demand <- list("RG", q, 0.5, 0.3, 1.7, Y)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("RG", p, 0.5, 1.7, X)
demand <- list("RG", q, 0.5, 1.7, Y)
# compute and plot the transport plan
sinkhorn_divergence(supply, demand, 1e-3, exp = 2)
hausdorff_divergence(supply, demand, 1e-3, exp = 2)
regularizedf_ot(supply, demand, 1e-3, exp = 2)
# compute and plot the transport plan
sinkhorn_divergence(supply, demand, 1e-3, exp = 2)
sinkhorn_divergence <- function(supplyList, demandList, eps, iterMax = 100, tol = 1e-3, method = "euclidean", exp = 1, p = 2,  wfr = FALSE,
Cxy = NULL, Cxx = NULL, Cyy = NULL){
lenSup <- length(supplyList)
lenDem <- length(demandList)
X <- supplyList[[lenSup]]
Y <- demandList[[lenDem]]
if(is.null(Cxy)){
Cxy <- costMatrix(X, Y , method, exp, wfr, p)
}
if(is.null(Cxx)){
Cxx <- costMatrix(X, X, method, exp, wfr, p)
}
if(is.null(Cyy)){
Cyy <- costMatrix(Y, Y , method, exp, wfr, p)
}
if(supplyList[[1]] != demandList[[1]]){
print("Please chose the same entropy for supply and demand.")
}
res_xy = sinkhornAlgorithmFromCost(Cxy, supplyList, demandList, iterMax, eps, tol)
res_x = sinkhornAlgorithmFromCost(Cxx, supplyList, supplyList, iterMax, eps, tol)
res_y = sinkhornAlgorithmFromCost(Cyy, demandList, demandList, iterMax, eps, tol)
f_xy = res_xy$dual_f
g_xy = res_xy$dual_g
f_x1 = res_x$dual_f
f_x2 = res_x$dual_g
g_y1 = res_y$dual_f
g_y2 = res_y$dual_g
if(supplyList[[1]] == "TV"){
print("TV")
func = sum(supplyList[[2]] * (f_xy - 0.5*f_x1 - 0.5*f_x2)) + sum(demandList[[2]] * (g_xy - 0.5*g_y1 -0.5*g_y2))
supxdem = supplyList[[2]] %*% t(demandList[[2]])
supxsup = supplyList[[2]] %*% t(supplyList[[2]])
demxdem = demandList[[2]] %*% t(demandList[[2]])
print(1-exp(expC(f_xy,g_xy,Cxy)/eps))
print(supxdem)
print(supxsup)
print(demxdem)
func = func + sum(supxdem * (1-exp(expC(f_xy,g_xy,Cxy)/eps)))
- 0.5*sum(supxsup * (1-exp(expC(f_x1,f_x2,Cxx)/eps)))
- 0.5*sum(demxdem * (1-exp(expC(g_y1,g_y2,Cyy)/eps)))
return(func)
}else if(supplyList[[1]] == "RG" ){
param1 <- supplyList[[3]]
param2 <- supplyList[[4]]
func = sum(supplyList[[2]] * (-legendre_entropy(0, -f_xy, supplyList[[1]], param1, param2)
- 0.5 * (-legendre_entropy(0, -f_x1, supplyList[[1]], param1, param2))
- 0.5 * (-legendre_entropy(0, -f_x2, supplyList[[1]], param1, param2))))
+ sum(demandList[[2]] * (-legendre_entropy(0, -g_xy, supplyList[[1]], param1, param2)
- 0.5 * (-legendre_entropy(0, -g_y1, supplyList[[1]], param1, param2))
- 0.5 * (-legendre_entropy(0, -g_y2, supplyList[[1]], param1, param2))))
supxdem = supplyList[[2]] %*% t(demandList[[2]])
supxsup = supplyList[[2]] %*% t(supplyList[[2]])
demxdem = demandList[[2]] %*% t(demandList[[2]])
func = func + sum(supxdem * (1-exp(expC(f_xy,g_xy,Cxy)/eps))) -
0.5*sum(supxsup * (1-exp(expC(f_x1,f_x2,Cxx)/eps))) -
0.5*sum(demxdem * (1-exp(expC(g_y1,g_y2,Cyy)/eps)))
return(func)
}else{
param1 <- 0
if(supplyList[[1]] == "Berg"){
supplyList[[1]] <- "Power"
demandList[[1]] <- "Power"
param1 <- 0
}else if(supplyList[[1]] == "Hellinger"){
supplyList[[1]] <- "Power"
demandList[[1]] <- "Power"
param1 <- -1
}else if(supplyList[[1]] == "Power"){
param1 <- supplyList[[4]]
}
outf_xy <- -legendre_entropy(supplyList[[3]], -f_xy, supplyList[[1]], param1) - 0.5*eps*grad_legrende(supplyList[[3]], -f_xy, supplyList[[1]], param1)
outf_xx <- -legendre_entropy(supplyList[[3]], -f_x1, supplyList[[1]], param1) - 0.5*eps*grad_legrende(supplyList[[3]], -f_x1, supplyList[[1]], param1)
outg_xy <- -legendre_entropy(supplyList[[3]], -g_xy, supplyList[[1]], param1) - 0.5*eps*grad_legrende(supplyList[[3]], -g_xy, supplyList[[1]], param1)
outg_yy <- -legendre_entropy(supplyList[[3]], -g_y1, supplyList[[1]], param1) - 0.5*eps*grad_legrende(supplyList[[3]], -g_y1, supplyList[[1]], param1)
out <- sum(supplyList[[2]]*(outf_xx-outf_xy)) + sum(demandList[[2]] * (outg_yy - outg_xy))
return(out)
}
}
# compute and plot the transport plan
sinkhorn_divergence(supply, demand, 1e-3, exp = 2)
hausdorff_divergence(supply, demand, 1e-3, exp = 2)
regularizedf_ot(supply, demand, 1e-3, exp = 2)
