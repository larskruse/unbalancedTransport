ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
#' supply <- c(0,0,1,2,0,0,0,0,0,0,0,0,0)
#' demand <- c(0,0,0,0,0,1,0,1,0,0,0,1,1)
#'
#' plotTree(tree, supply = supply, demand = demand)
#'
#'
#' tList = list(c(3,6,1), c(4,8,1))
#' plotTree(tree, tList, supply, demand)
#'
#'
plotTree <- function(tree, tList = NULL , supply = NULL, demand = NULL){
if(length(tList) == 0){
tList <- NULL
}
# create a tree data frame
treeDF <- as.data.frame(do.call(rbind, tree[-1]))
colnames(treeDF) <- c("parent", "child", "weight")
treeDF <- treeDF[order(treeDF$parent),]
rootNode <- tree[1]
# initiate a data frame to hold the coordianates for the tree nodes
coordinates <- data.frame(c(rootNode, 0, 0, 100,-100,-1))
colnames(coordinates) <- c("node", "x", "layer", "maxX", "minX", "parent")
# compute all coordinates
coordinates <- nextLayer(treeDF, coordinates, rootNode, -1)
maxLayer <- min(coordinates$layer)
coordinates$layer <- coordinates$layer * 100/(-maxLayer)
maxLayer <- min(coordinates$layer)
# add the supply to the coordiantes
if(!is.null(supply) & !is.null(demand)){
supDem <- supply-demand
coordinates$supply <- supDem[coordinates$node]
}
# create an empty plot
plot(1, type = "n", xlab = "", ylab = "", xlim = c(-110, 110), ylim = c(maxLayer-1,1), axes = FALSE)
# plot the edges
for(i in 1:nrow(treeDF)){
segments(coordinates[coordinates$node == treeDF[i,]$parent,]$x,
coordinates[coordinates$node == treeDF[i,]$parent,]$layer,
coordinates[coordinates$node == treeDF[i,]$child,]$x,
coordinates[coordinates$node == treeDF[i,]$child,]$layer)
}
# If the supply and demand are not given, plot all nodes in black.
if(is.null(supply) | is.null(demand)){
points(coordinates$x, coordinates$layer,pch = 19 )
# Otherwise plot supply nodes in green and demand nodes in blue.
# The radius of the node indicates the amount of supply / demand: The bigger the node
# the more mass is supplied or demanded.
# Nodes without supply or demand are plotted in black.
}else{
points(coordinates[coordinates$supply  == 0, ]$x, coordinates[coordinates$supply  == 0, ]$layer,
pch = 19 )
points(coordinates[coordinates$supply  > 0, ]$x, coordinates[coordinates$supply  > 0, ]$layer,
pch = 19, cex = abs(coordinates[coordinates$supply > 0, ]$supply),  col = "chartreuse3")
points(coordinates[coordinates$supply  < 0, ]$x, coordinates[coordinates$supply  < 0, ]$layer,
pch = 19, cex = abs(coordinates[coordinates$supply  < 0, ]$supply),  col = "dodgerblue3")
}
# If a transport plan is given, plot the transport paths as arrows
if(!is.null(tList)){
treeDF$tMass <- rep(0, nrow(treeDF))
for(i in 1:length(tList)){
# Finding a path for each transport list entry
pathTo <- unlist(findPath(tList[[i]][1], tList[[i]][2], treeDF))
pathFrom <- NULL
# If the path was not found, the receiving node is not a child of the
# origin node
if(is.null(pathTo)){
# compute the paths from the trees root node to each of the two nodes.
# The path between the two nodes can be computed from these two paths.
pathTo <- unlist(findPath(rootNode, tList[[i]][2], treeDF))
pathFrom <- unlist(findPath(rootNode, tList[[i]][1], treeDF))
while(length(pathFrom) > 1 & length(pathTo) > 1 & pathFrom[2] == pathTo[2]){
pathTo <- pathTo[-1]
pathFrom <- pathFrom[-1]
}
}
if(length(pathTo) > 1){
for(j in 1:(length(pathTo)-1)){
treeDF[(treeDF$parent == pathTo[j] & treeDF$child == pathTo[j+1]),]$tMass =
tList[[i]][3] + treeDF[(treeDF$parent == pathTo[j] & treeDF$child == pathTo[j+1]),]$tMass
}
}
if(length(pathFrom) > 1){
for(j in 1:(length(pathFrom)-1)){
treeDF[(treeDF$parent == pathFrom[j] & treeDF$child == pathFrom[j+1]),]$tMass =
- tList[[i]][3] + treeDF[(treeDF$parent == pathFrom[j] & treeDF$child == pathFrom[j+1]),]$tMass
}
}
}
arrowsDF <- treeDF[treeDF$tMass != 0, ]
# Plotting the arrows.
# The line width indicates the amount of mass moves along that edge.
for(i in 1:nrow(arrowsDF)){
fromX <- coordinates[coordinates$node == arrowsDF[i,]$parent,]$x
fromY <- coordinates[coordinates$node == arrowsDF[i,]$parent,]$layer
toX <- coordinates[coordinates$node == arrowsDF[i,]$child,]$x
toY <- coordinates[coordinates$node == arrowsDF[i,]$child,]$layer
curvedarrow(c(fromX, fromY), c(toX, toY), arr.adj = 1, arr.pos = 0.5,arr.type = "triangle", curve = 0.2,
lwd = abs(arrowsDF[i,]$tMass), lcol = "red", arr.col = "red")  #, code = 1.5+0.5*sign(arrowsDF[i,]$tMass) )
#curvedarrow(c(x[i],y[i]),c(x[j],y[j]), lwd = 0.5+transportPlan[[i,j]],
#            arr.pos = 0.5, arr.adj = 0.5, arr.type = "triangle",
#            curve = 0.2)
}
}
# Adding the keys to the plot.
text(coordinates$x, coordinates$layer, labels = coordinates$node, pos = 4)
}
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
ExampleTree1()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree1()
ExampleTree2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleTree2()
ExampleTree1()
ExampleScaling2()
ExampleScaling()
Eigen::sum
library(unbalancedTransport)
vectorDivergence(c(1),c(2), 1, 0.4)
1*log(1/2)-1+2
(1*log(1/2)-1+2)*0.4
log(1/2)
log(10)
log(e)
log(exp(1))
vectorDivergence(c(1),c(2), 2, 0.4)
vectorDivergence(c(2,3),c(4,5), 2, 0.4)
aa <- 2*log(2/4)+3*log(3/5)+9-5
aa
vectorDivergence(c(2,3),c(4,5), 1, 0.4)
aa*0.4
fvectorDivergence(c(2,3),c(4,5), 1, 0.4)
library(unbalancedTransport)
vectorDivergence(c(2,3),c(4,5), 1, 0.4)
fvectorDivergence(c(2,3),c(4,5), 1, 0.4)
fVectorDivergence
fVectorDivergence(c(2,3),c(4,5), 1, 0.4)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
x
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
#' The Scaling Algorithm Example
#'
#' Another scaling algorithm example
#'
#' @export
#'
ExampleScaling2 <- function(){
xx <- c(0,0,0,3,3.5,4)
xy <- c(0,1,2,1.7,1,0.2)
# supply measure
p <- c(2,2,2,0,0,0)
q <- c(0,0,0,1,2,3)
# number of iterations
iterMax <- 10000
# vector of epsilon values
epsvec <- seq(-1,-7, length.out = 20)
epsvec <- 10^(epsvec)
#compute quadrature cost matrix
C <- createCostMatrix(xx,xy)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand vectors.")
cat("The euclidean distance matrix is used. \n")
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
print("aeas")
# compute and plot the transport plan
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
print("yeah")
# print(res)
# transportP <- res$transportPlan
#
# transportP <- transportP*6
#
# plotUOTP(transportP)
#
# plotTransportByCost(C, transportP, p, q)
}
#' The Scaling Algorithm Example
#'
#' Another scaling algorithm example
#'
#' @export
#'
ExampleScaling2 <- function(){
xx <- c(0,0,0,3,3.5,4)
xy <- c(0,1,2,1.7,1,0.2)
# supply measure
p <- c(2,2,2,0,0,0)
q <- c(0,0,0,1,2,3)
# number of iterations
iterMax <- 10000
# vector of epsilon values
epsvec <- seq(-1,-7, length.out = 20)
epsvec <- 10^(epsvec)
#compute quadrature cost matrix
C <- createCostMatrix(xx,xy)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand vectors.")
cat("The euclidean distance matrix is used. \n")
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
print("aeas")
# compute and plot the transport plan
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
print("yeah")
# print(res)
# transportP <- res$transportPlan
#
# transportP <- transportP*6
#
# plotUOTP(transportP)
#
# plotTransportByCost(C, transportP, p, q)
}
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
#' The Scaling Algorithm Example
#'
#' Another scaling algorithm example
#'
#' @export
#'
ExampleScaling2 <- function(){
xx <- c(0,0,0,3,3.5,4)
xy <- c(0,1,2,1.7,1,0.2)
# supply measure
p <- c(2,2,2,0,0,0)
q <- c(0,0,0,1,2,3)
# number of iterations
iterMax <- 10000
# vector of epsilon values
epsvec <- seq(-1,-7, length.out = 20)
epsvec <- 10^(epsvec)
#compute quadrature cost matrix
C <- createCostMatrix(xx,xy)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand vectors.")
cat("The euclidean distance matrix is used. \n")
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
# compute and plot the transport plan
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
print(res)
transportP <- res$transportPlan
#
plotUOTP(transportP)
#
plotTransportByCost(C, transportP, p, q)
}
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
#' The Scaling Algorithm Example
#'
#' Another scaling algorithm example
#'
#' @export
#'
ExampleScaling2 <- function(){
xx <- c(0,0,0,3,3.5,4)
xy <- c(0,1,2,1.7,1,0.2)
# supply measure
p <- c(2,2,2,0,0,0)
q <- c(0,0,0,1,2,3)
# number of iterations
iterMax <- 10000
# vector of epsilon values
epsvec <- seq(-1,-7, length.out = 20)
epsvec <- 10^(epsvec)
#compute quadrature cost matrix
C <- createCostMatrix(xx,xy)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand vectors.")
cat("The euclidean distance matrix is used. \n")
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
# compute and plot the transport plan
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
print(res)
transportP <- res$TransportPlan
#
print(transportP)
plotUOTP(transportP)
#
plotTransportByCost(C, transportP, p, q)
}
#' The Scaling Algorithm Example
#'
#' Another scaling algorithm example
#'
#' @export
#'
ExampleScaling2 <- function(){
xx <- c(0,0,0,3,3.5,4)
xy <- c(0,1,2,1.7,1,0.2)
# supply measure
p <- c(2,2,2,0,0,0)
q <- c(0,0,0,1,2,3)
# number of iterations
iterMax <- 10000
# vector of epsilon values
epsvec <- seq(-1,-7, length.out = 20)
epsvec <- 10^(epsvec)
#compute quadrature cost matrix
C <- createCostMatrix(xx,xy)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand vectors.")
cat("The euclidean distance matrix is used. \n")
supply <- list("KL", p, 0.5)
demand <- list("KL", q, 0.5)
# compute and plot the transport plan
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
print(res)
transportP <- res$TransportPlan
#
print(transportP)
plotUOTP(transportP)
#
plotTransportByCost(C, transportP, p, q)
}
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
library(unbalancedTransport)
library(unbalancedTransport)
ExampleScaling2()
#' The Scaling Algorithm Example
#'
#' Another scaling algorithm example
#'
#' @export
#'
ExampleScaling2 <- function(){
xx <- c(0,0,0,3,3.5,4)
xy <- c(0,1,2,1.7,1,0.2)
# supply measure
p <- c(2,2,2,0,0,0)
q <- c(0,0,0,1,2,3)
# number of iterations
iterMax <- 10000
# vector of epsilon values
epsvec <- seq(-1,-7, length.out = 20)
epsvec <- 10^(epsvec)
#compute quadrature cost matrix
C <- createCostMatrix(xx,xy)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand vectors.")
cat("The euclidean distance matrix is used. \n")
supply <- list("TV", p, 0.5)
demand <- list("TV", q, 0.5)
# compute and plot the transport plan
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
print(res)
transportP <- res$TransportPlan
#
print(transportP)
plotUOTP(transportP)
#
plotTransportByCost(C, transportP, p, q)
}
ExampleScaling2()
#' The Scaling Algorithm Example
#'
#' Another scaling algorithm example
#'
#' @export
#'
ExampleScaling2 <- function(){
xx <- c(0,0,0,3,3.5,4)
xy <- c(0,1,2,1.7,1,0.2)
# supply measure
p <- c(2,2,2,0,0,0)
q <- c(0,0,0,1,2,3)
# number of iterations
iterMax <- 10000
# vector of epsilon values
epsvec <- seq(-1,-7, length.out = 20)
epsvec <- 10^(epsvec)
#compute quadrature cost matrix
C <- createCostMatrix(xx,xy)
cat("Number of iterations: ", iterMax, "\n")
cat("Epsilon values: ", epsvec, "\n")
cat("The KL divergence with parameter 0.5 is used for both supply and demand vectors.")
cat("The euclidean distance matrix is used. \n")
supply <- list("TV", p, 3)
demand <- list("TV", q, 3)
# compute and plot the transport plan
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
print(res)
transportP <- res$TransportPlan
#
print(transportP)
plotUOTP(transportP)
#
plotTransportByCost(C, transportP, p, q)
}
ExampleScaling2()
library(unbalancedTransport)
