for(i in 1:Nx){
for(j in 1:Ny){
tPlan[i,j] <- exp((f[i] + g[j] -costMatrix[i,j])/eps)
}
}
tPlan <- tPlan * (supply %*% t(demand))
return(list(f,g,tPlan))
}
res <- sink(C, supplyy, demandy, supplyReg, supplyAlpha,
supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
Div2, iterMax, epsvec)
sink <- function(costMatrix, supply, demand, lambdaSupply, param1Supply, param2Supply, lambdaDemand, param1Demand, param2Demand, DivSupply, DivDemand, iterMax, eps){
Nx <- length(supply)
Ny <- length(demand)
logSup <- log(supply)
logDem <- log(demand)
print("logs")
print(logSup)
print(logDem)
f <- rep(0,Ny)
g <- rep(0,Nx)
temp <- matrix(0, Nx,Ny)
tPlan <- matrix(0, Nx,Ny)
print("f / g")
print(f)
print(g)
print(costMatrix)
for(k in 1:1){
print(f)
temp <- sweep(costMatrix,2,f,"-")
print(temp)
temp <- -temp
print(temp)
temp <- temp/eps
temp <- sweep(temp, 2, logSup, "+")
print(temp)
g <- colLogSumExps(temp)
print(g)
g <- -eps*g
print(g)
g <- lambdaSupply/(eps+lambdaSupply) * g
print(g)
#temp <-  sweep(-(sweep(t(costMatrix),2,g,"-")/eps), 2, logDem, "+")
# print(costMatrix)
temp <- sweep(costMatrix,1,g,"-")
print(temp)
temp <- -temp
temp <- temp/eps
print(temp)
temp <- sweep(temp, 2, logDem, "+")
print(temp)
f <- colLogSumExps(t(temp))
print(f)
f <- -eps*f
print(f)
f <- lambdaDemand/(eps+lambdaDemand)  * f
print(f)
}
print("f / g")
print(f)
print(g)
for(i in 1:Nx){
for(j in 1:Ny){
tPlan[i,j] <- exp((f[i] + g[j] -costMatrix[i,j])/eps)
}
}
tPlan <- tPlan * (supply %*% t(demand))
return(list(f,g,tPlan))
}
res <- sink(C, supplyy, demandy, supplyReg, supplyAlpha,
supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
Div2, iterMax, epsvec)
sink <- function(costMatrix, supply, demand, lambdaSupply, param1Supply, param2Supply, lambdaDemand, param1Demand, param2Demand, DivSupply, DivDemand, iterMax, eps){
Nx <- length(supply)
Ny <- length(demand)
logSup <- log(supply)
logDem <- log(demand)
print("logs")
print(logSup)
print(logDem)
f <- rep(0,Ny)
g <- rep(0,Nx)
temp <- matrix(0, Nx,Ny)
tPlan <- matrix(0, Nx,Ny)
print("f / g")
print(f)
print(g)
print(costMatrix)
for(k in 1:1){
print(f)
temp <- sweep(costMatrix,1,f,"-")
print(temp)
temp <- -temp
print(temp)
temp <- temp/eps
temp <- sweep(temp, 1, logSup, "+")
print(temp)
g <- colLogSumExps(temp)
print(g)
g <- -eps*g
print(g)
g <- lambdaSupply/(eps+lambdaSupply) * g
print(g)
#temp <-  sweep(-(sweep(t(costMatrix),2,g,"-")/eps), 2, logDem, "+")
# print(costMatrix)
temp <- sweep(costMatrix,1,g,"-")
print(temp)
temp <- -temp
temp <- temp/eps
print(temp)
temp <- sweep(temp, 2, logDem, "+")
print(temp)
f <- colLogSumExps(t(temp))
print(f)
f <- -eps*f
print(f)
f <- lambdaDemand/(eps+lambdaDemand)  * f
print(f)
}
print("f / g")
print(f)
print(g)
for(i in 1:Nx){
for(j in 1:Ny){
tPlan[i,j] <- exp((f[i] + g[j] -costMatrix[i,j])/eps)
}
}
tPlan <- tPlan * (supply %*% t(demand))
return(list(f,g,tPlan))
}
res <- sink(C, supplyy, demandy, supplyReg, supplyAlpha,
supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
Div2, iterMax, epsvec)
sink <- function(costMatrix, supply, demand, lambdaSupply, param1Supply, param2Supply, lambdaDemand, param1Demand, param2Demand, DivSupply, DivDemand, iterMax, eps){
Nx <- length(supply)
Ny <- length(demand)
logSup <- log(supply)
logDem <- log(demand)
print("logs")
print(logSup)
print(logDem)
f <- rep(0,Ny)
g <- rep(0,Nx)
temp <- matrix(0, Nx,Ny)
tPlan <- matrix(0, Nx,Ny)
print("f / g")
print(f)
print(g)
print(costMatrix)
for(k in 1:1){
print(f)
temp <- sweep(costMatrix,1,f,"-")
print(temp)
temp <- -temp
print(temp)
temp <- temp/eps
temp <- sweep(temp, 1, logSup, "+")
print(temp)
g <- colLogSumExps(temp)
print(g)
g <- -eps*g
print(g)
g <- lambdaSupply/(eps+lambdaSupply) * g
print(g)
#temp <-  sweep(-(sweep(t(costMatrix),2,g,"-")/eps), 2, logDem, "+")
# print(costMatrix)
temp <- sweep(costMatrix,2,g,"-")
print(temp)
temp <- -temp
temp <- temp/eps
print(temp)
temp <- sweep(temp, 2, logDem, "+")
print(temp)
f <- colLogSumExps(t(temp))
print(f)
f <- -eps*f
print(f)
f <- lambdaDemand/(eps+lambdaDemand)  * f
print(f)
}
print("f / g")
print(f)
print(g)
for(i in 1:Nx){
for(j in 1:Ny){
tPlan[i,j] <- exp((f[i] + g[j] -costMatrix[i,j])/eps)
}
}
tPlan <- tPlan * (supply %*% t(demand))
return(list(f,g,tPlan))
}
res <- sink(C, supplyy, demandy, supplyReg, supplyAlpha,
supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
Div2, iterMax, epsvec)
sink <- function(costMatrix, supply, demand, lambdaSupply, param1Supply, param2Supply, lambdaDemand, param1Demand, param2Demand, DivSupply, DivDemand, iterMax, eps){
Nx <- length(supply)
Ny <- length(demand)
logSup <- log(supply)
logDem <- log(demand)
print("logs")
print(logSup)
print(logDem)
f <- rep(0,Ny)
g <- rep(0,Nx)
temp <- matrix(0, Nx,Ny)
tPlan <- matrix(0, Nx,Ny)
print("f / g")
print(f)
print(g)
print(costMatrix)
for(k in 1:1000){
print(f)
temp <- sweep(costMatrix,1,f,"-")
print(temp)
temp <- -temp
print(temp)
temp <- temp/eps
temp <- sweep(temp, 1, logSup, "+")
print(temp)
g <- colLogSumExps(temp)
print(g)
g <- -eps*g
print(g)
g <- lambdaSupply/(eps+lambdaSupply) * g
print(g)
#temp <-  sweep(-(sweep(t(costMatrix),2,g,"-")/eps), 2, logDem, "+")
# print(costMatrix)
temp <- sweep(costMatrix,2,g,"-")
print(temp)
temp <- -temp
temp <- temp/eps
print(temp)
temp <- sweep(temp, 2, logDem, "+")
print(temp)
f <- colLogSumExps(t(temp))
print(f)
f <- -eps*f
print(f)
f <- lambdaDemand/(eps+lambdaDemand)  * f
print(f)
}
print("f / g")
print(f)
print(g)
for(i in 1:Nx){
for(j in 1:Ny){
tPlan[i,j] <- exp((f[i] + g[j] -costMatrix[i,j])/eps)
}
}
tPlan <- tPlan * (supply %*% t(demand))
return(list(f,g,tPlan))
}
res <- sink(C, supplyy, demandy, supplyReg, supplyAlpha,
supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
Div2, iterMax, epsvec)
res
plotUOTP(res[[3]])
sink <- function(costMatrix, supply, demand, lambdaSupply, param1Supply, param2Supply, lambdaDemand, param1Demand, param2Demand, DivSupply, DivDemand, iterMax, eps){
Nx <- length(supply)
Ny <- length(demand)
logSup <- log(supply)
logDem <- log(demand)
# print("logs")
# print(logSup)
# print(logDem)
f <- rep(0,Ny)
g <- rep(0,Nx)
temp <- matrix(0, Nx,Ny)
tPlan <- matrix(0, Nx,Ny)
# print("f / g")
#
# print(f)
# print(g)
# print(costMatrix)
for(k in 1:1000){
# print(f)
temp <- sweep(costMatrix,1,f,"-")
# print(temp)
temp <- -temp
# print(temp)
temp <- temp/eps
temp <- sweep(temp, 1, logSup, "+")
# print(temp)
g <- colLogSumExps(temp)
# print(g)
g <- -eps*g
# print(g)
g <- lambdaSupply/(eps+lambdaSupply) * g
# print(g)
#temp <-  sweep(-(sweep(t(costMatrix),2,g,"-")/eps), 2, logDem, "+")
# print(costMatrix)
temp <- sweep(costMatrix,2,g,"-")
# print(temp)
temp <- -temp
temp <- temp/eps
# print(temp)
temp <- sweep(temp, 2, logDem, "+")
# print(temp)
f <- colLogSumExps(t(temp))
# print(f)
f <- -eps*f
# print(f)
f <- lambdaDemand/(eps+lambdaDemand)  * f
# print(f)
}
# print("f / g")
#
# print(f)
# print(g)
for(i in 1:Nx){
for(j in 1:Ny){
tPlan[i,j] <- exp((f[i] + g[j] -costMatrix[i,j])/eps)
}
}
tPlan <- tPlan * (supply %*% t(demand))
return(list(f,g,tPlan))
}
res <- sink(C, supplyy, demandy, supplyReg, supplyAlpha,
supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
Div2, iterMax, epsvec)
res
sink <- function(costMatrix, supply, demand, lambdaSupply, param1Supply, param2Supply, lambdaDemand, param1Demand, param2Demand, DivSupply, DivDemand, iterMax, eps){
Nx <- length(supply)
Ny <- length(demand)
logSup <- log(supply)
logDem <- log(demand)
# print("logs")
# print(logSup)
# print(logDem)
f <- rep(0,Ny)
g <- rep(0,Nx)
temp <- matrix(0, Nx,Ny)
tPlan <- matrix(0, Nx,Ny)
# print("f / g")
#
# print(f)
# print(g)
# print(costMatrix)
for(k in 1:iterMax){
# print(f)
temp <- sweep(costMatrix,1,f,"-")
# print(temp)
temp <- -temp
# print(temp)
temp <- temp/eps
temp <- sweep(temp, 1, logSup, "+")
# print(temp)
g <- colLogSumExps(temp)
# print(g)
g <- -eps*g
# print(g)
g <- lambdaSupply/(eps+lambdaSupply) * g
# print(g)
#temp <-  sweep(-(sweep(t(costMatrix),2,g,"-")/eps), 2, logDem, "+")
# print(costMatrix)
temp <- sweep(costMatrix,2,g,"-")
# print(temp)
temp <- -temp
temp <- temp/eps
# print(temp)
temp <- sweep(temp, 2, logDem, "+")
# print(temp)
f <- colLogSumExps(t(temp))
# print(f)
f <- -eps*f
# print(f)
f <- lambdaDemand/(eps+lambdaDemand)  * f
# print(f)
}
# print("f / g")
#
# print(f)
# print(g)
for(i in 1:Nx){
for(j in 1:Ny){
tPlan[i,j] <- exp((f[i] + g[j] -costMatrix[i,j])/eps)
}
}
tPlan <- tPlan * (supply %*% t(demand))
return(list(f,g,tPlan))
}
start_time <- Sys.time()
res <- sink(C, supplyy, demandy, supplyReg, supplyAlpha,
supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
Div2, iterMax, epsvec)
res
end_time <- Sys.time()
nn <- 250
pa1 <- seq(0,0.2, length.out=nn)
pa1
a1 <- rep(1,nn)
a1[1] <- 0
a1[nn] <- 0
a1 <- a1/sum(a1)
a1 <- 0.65*a1
a1
pa2 <- seq(0.9,1, length.out = nn)
a2 <- 0.05-abs(pa2-0.95)
a2[0] <- 0
a2[nn] <- 0
a2 = a2/sum(a2)
a2 <- a2*0.35
a2
p = c(a1,a2)
X = c(pa1, pa2)
qa1 <- seq(0.2,0.4, length.out=nn)
b1 <- seq(0,1,length.out = nn)
b1[0] <- 0
b1[nn] <- 0
b1 <- b1/sum(b1)
b1 <- b1*0.45
qa2 <- seq(0.5,0.9, length.out = nn)
b2 <- sqrt(abs(1-((qa2-0.7)/0.2)^2))
b2[1] <- 0
b2[nn] <- 0
b2 <- b2/sum(b2)
b2 <- 0.55*b2
b2
q <- c(b1, b2)
Y <- c(qa1, qa2)
X
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.05)
demand <- list("KL", q, 0.05)
# number of iterations
iterMax <- 1000
# vector of epsilon values
epsvec <- 10^(-3)
library(unbalancedTransport)
start_time <- Sys.time()
ress <- sinkhornAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
supplyy <- supply[[2]]
demandy <- demand[[2]]
Div1 <- 1
supplyReg <- supply[[3]]
Div2 <- 1
demandReg <- demand[[3]]
supplyy <- supply[[2]]
demandy <- demand[[2]]
start_time <- Sys.time()
res <- sink(C, supplyy, demandy, supplyReg, supplyAlpha,
supplyBeta, demandReg, demandAlpha, demandBeta, Div1,
Div2, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
plotUOTP(res[[3]])
plotUOTP(ress$TransportPlan)
library(unbalancedTransport)
start_time <- Sys.time()
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
# number of iterations
iterMax <- 1000
# vector of epsilon values
epsvec <- 10^(-3)
nn <- 500
pa1 <- seq(0,0.2, length.out=nn)
pa1
a1 <- rep(1,nn)
a1[1] <- 0
a1[nn] <- 0
a1 <- a1/sum(a1)
a1 <- 0.65*a1
a1
pa2 <- seq(0.9,1, length.out = nn)
a2 <- 0.05-abs(pa2-0.95)
a2[0] <- 0
a2[nn] <- 0
a2 = a2/sum(a2)
a2 <- a2*0.35
a2
p = c(a1,a2)
X = c(pa1, pa2)
qa1 <- seq(0.2,0.4, length.out=nn)
b1 <- seq(0,1,length.out = nn)
b1[0] <- 0
b1[nn] <- 0
b1 <- b1/sum(b1)
b1 <- b1*0.45
qa2 <- seq(0.5,0.9, length.out = nn)
b2 <- sqrt(abs(1-((qa2-0.7)/0.2)^2))
b2[1] <- 0
b2[nn] <- 0
b2 <- b2/sum(b2)
b2 <- 0.55*b2
b2
q <- c(b1, b2)
Y <- c(qa1, qa2)
X
# supply/demand with discretization and reference measure
supplyList <- list(p, X)
demandList <- list(q, Y)
#compute quadrature cost matrix
C <-  costMatrix(X,Y, exp = 2)
# use Kulback-Leibner divergence with lambda = 0.5 for supply and demand
supply <- list("KL", p, 0.05)
demand <- list("KL", q, 0.05)
start_time <- Sys.time()
end_time <- Sys.time()
print(end_time - start_time)
start_time <- Sys.time()
res <- scalingAlgorithmFromCost(C, supply, demand, iterMax, epsvec)
end_time <- Sys.time()
print(end_time - start_time)
