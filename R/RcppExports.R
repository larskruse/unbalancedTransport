# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' init the lambert w function
#' @param x numeric vector
#' @return initial value 
#' @export
lambertInit <- function(x) {
    .Call(`_unbalancedTransport_lambertInit`, x)
}

#' computing the lambert w function
#' @param x numeric vector
#' @return the function value
#' @export
lambertWFunctionLog <- function(x) {
    .Call(`_unbalancedTransport_lambertWFunctionLog`, x)
}

#' computing the inital values for f and g
#' @param x numeric vector
#' @return the function value
#' @export
inital <- function(x) {
    .Call(`_unbalancedTransport_inital`, x)
}

#' The aprox operator
#'
#' The aprix operators for different divergences in the form of 'lambda * DivFun(.|p)'
#' Implemented are the operators for the Kullback-Leibler divergence and total variation.
#'
#' @param lambda Regularization parameter
#' @param p A numeric vector
#' @param eps The epsilon value
#' @param DivFun A numeric value indicating the function to be used.'1' gives
#'   the proxdiv operator for the Kullback-Leibler divergence and '2' the opterator
#'   for the total variation.
#' @param param1 num value
#' @param param2 num value
#' @return A vector holding the proxdiv evaluation
#' @export
aprox <- function(lambda, p, eps, DivFun, param1, param2) {
    .Call(`_unbalancedTransport_aprox`, lambda, p, eps, DivFun, param1, param2)
}

#' Inital values
#'
#' The aprix operators for different divergences in the form of 'lambda * DivFun(.|p)'
#' Implemented are the operators for the Kullback-Leibler divergence and total variation.
#'
#' @param lambda Regularization parameter
#' @param costMatrix A numeric matrix
#' @param distribution A numeric vector
#' @param secDistribution A numeric vector
#' @param DivFun A numeric value indicating the function to be used.'1' gives
#'   the proxdiv operator for the Kullback-Leibler divergence and '2' the opterator
#'   for the total variation.
#' @param param1 num value
#' @param param2 num value
#' @param Nx num value
#' @param Ny num value
#' @param eps eps value
#' @return A vector holding the proxdiv evaluation
#' @export
init_vectors <- function(lambda, costMatrix, distribution, secDistribution, DivFun, param1, param2, Nx, Ny, eps) {
    .Call(`_unbalancedTransport_init_vectors`, lambda, costMatrix, distribution, secDistribution, DivFun, param1, param2, Nx, Ny, eps)
}

#' The stabilized Scaling Algorithm
#'
#' C++ implementation of the log-domain stabilized Version of the Scaling
#' Algorithm.
#'
#' @param costMatrix A numeric matrix.
#' @param supply A numeric vector
#' @param demand A numeric vector
#' @param lambdaSupply Parameter for the supply proxdiv function
#' @param lambdaDemand Parameter for the demand proxdiv function
#' @param DivSupply Parameter indicating the divergence function to use for the supply proxdiv function
#' @param DivDemand Parameter indicating the divergence function to use for the demand proxdiv function
#' @param iterMax Maximum number of iterations
#' @param eps A numeric vector of decreasing epsilon values.
#' @param param1Supply numeric Value
#' @param param2Supply numeric value
#' @param param1Demand numeric Value
#' @param param2Demand numeric value
#' @param tol numeric value
#'
#' @return The optimal transport plan
#' @export
Sinkhorn_Rcpp <- function(costMatrix, supply, demand, lambdaSupply, param1Supply, param2Supply, lambdaDemand, param1Demand, param2Demand, DivSupply, DivDemand, iterMax, eps, tol) {
    .Call(`_unbalancedTransport_Sinkhorn_Rcpp`, costMatrix, supply, demand, lambdaSupply, param1Supply, param2Supply, lambdaDemand, param1Demand, param2Demand, DivSupply, DivDemand, iterMax, eps, tol)
}

#' The symmetric stabilized Scaling Algorithm
#'
#' C++ implementation of the log-domain stabilized Version of the Scaling
#' Algorithm.
#'
#' @param costMatrix A numeric matrix.
#' @param f A numeric vector
#' @param lambda Parameter for the supply proxdiv function
#' @param Div Parameter indicating the divergence function to use for the supply proxdiv function
#' @param eps A numeric vector of decreasing epsilon values.
#' @param param1 numeric Value
#' @param param2 numeric value
#' @param distribution num distrie
#'
#' @return The optimal transport plan
#' @export
Hausdorff_Vec_Rcpp <- function(costMatrix, distribution, f, lambda, param1, param2, Div, eps) {
    .Call(`_unbalancedTransport_Hausdorff_Vec_Rcpp`, costMatrix, distribution, f, lambda, param1, param2, Div, eps)
}

#' C++ implementation of the Monge algorithm
#'
#' This function calculates the optimal transport cost and transport
#' plan for unbalanced optimal transport problems with a Monge cost matrix
#'
#'
#' @param costMatrix A numeric matrix that fulfills the Monge property
#' @param supply A numeric vector. Its length must be equal to the numbers of rows in the cost matrix.
#' @param demand A numeric vector. Its length must be equal to the number of column in the cost matrix.
#' @param constructionCost The cost of creating mass at any point.
#' @param destructionCost The cost of destructing mass at any point.
#' @return It returns a list of the transport cost, three numeric vectors that indicate the optimal transport path, and two vectors that indicate
#'     where mass is created and where it is destructed.
#' @export
Monge_Rcpp <- function(costMatrix, supply, demand, constructionCost, destructionCost) {
    .Call(`_unbalancedTransport_Monge_Rcpp`, costMatrix, supply, demand, constructionCost, destructionCost)
}

#' Computing the divergence functions values
#'
#' @param r input vector
#' @param s comparision vector
#' @param DivFun kind of function to use
#' @param param1 lambda or alpha
#' @param param2 beta or 0
#'
#' @export
#'
vectorDivergence <- function(r, s, DivFun, param1, param2 = 0) {
    .Call(`_unbalancedTransport_vectorDivergence`, r, s, DivFun, param1, param2)
}

#' The proxdiv operator
#'
#' The proxdiv operators for different divergences in the form of 'lambda * DivFun(.|p)'
#' Implemented are the operators for the Kullback-Leibler divergence and total variation.
#'
#' @param lambda Regularization parameter
#' @param p A numeric vector
#' @param s A numeric vector
#' @param u A numeric vector
#' @param eps The epsilon value
#' @param DivFun A numeric value indicating the function to be used.'1' gives
#'   the proxdiv operator for the Kullback-Leibler divergence and '2' the opterator
#'   for the total variation.
#' @param alpha num value
#' @param beta num value
#' @return A vector holding the proxdiv evaluation
#' @export
proxdiv <- function(lambda, p, s, u, eps, DivFun, alpha, beta) {
    .Call(`_unbalancedTransport_proxdiv`, lambda, p, s, u, eps, DivFun, alpha, beta)
}

#' The stabilized Scaling Algorithm
#'
#' C++ implementation of the log-domain stabilized Version of the Scaling
#' Algorithm.
#'
#' @param costMatrix A numeric matrix.
#' @param supply A numeric vector
#' @param demand A numeric vector
#' @param lambdaSupply Parameter for the supply proxdiv function
#' @param lambdaDemand Parameter for the demand proxdiv function
#' @param DivSupply Parameter indicating the divergence function to use for the supply proxdiv function
#' @param DivDemand Parameter indicating the divergence function to use for the demand proxdiv function
#' @param iterMax Maximum number of iterations
#' @param epsvec A numeric vector of decreasing epsilon values.
#' @param alphaSupply numeric Value
#' @param betaSupply numeric value
#' @param alphaDemand numeric Value
#' @param betaDemand numeric value
#' @param tol num vale
#'
#' @return The optimal transport plan
#' @export
StabilizedScaling_Rcpp <- function(costMatrix, supply, demand, lambdaSupply, alphaSupply, betaSupply, lambdaDemand, alphaDemand, betaDemand, DivSupply, DivDemand, iterMax, epsvec, tol = 1e-10) {
    .Call(`_unbalancedTransport_StabilizedScaling_Rcpp`, costMatrix, supply, demand, lambdaSupply, alphaSupply, betaSupply, lambdaDemand, alphaDemand, betaDemand, DivSupply, DivDemand, iterMax, epsvec, tol)
}

treegkr_Rcpp <- function(tree, supply, demand, creation, destruction) {
    .Call(`_unbalancedTransport_treegkr_Rcpp`, tree, supply, demand, creation, destruction)
}

#' C++ implantation of the North-West Corner Rule
#'
#' This function calculates the optimal transport cost for a balanced optimal
#' transport problem if its cost matrix fulfills the Monge property. Otherwise,
#' it calculates a feasible solution for the transport problme.
#'
#' @param costMatrix A numeric matrix.
#' @param supply A numeric supply vector.
#' @param demand A numeric demand vector.
#' @param iList A numeric vector holding the row index of the transport path
#' @param jList A numeric vector holding the row index of the transport path
#' @param weightList A numeric vector holding the transport path weights
#' @return The transport cost.
#' @export
Nw_Corner_Rule <- function(costMatrix, supply, demand, iList, jList, weightList) {
    .Call(`_unbalancedTransport_Nw_Corner_Rule`, costMatrix, supply, demand, iList, jList, weightList)
}

