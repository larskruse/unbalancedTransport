# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' The proxdiv operator
#'
#' The proxdiv operators for different divergences in the form of 'lambda * DivFun(.|p)'
#' Implemented are the operators for the Kullback-Leibler divergence and total variation.
#'
#' @param lambda Regularization parameter
#' @param p A numeric vector
#' @param s A numeric vector
#' @param u A numeric vector
#' @param eps The epsilon value
#' @param DivFun A numeric value indicating the function to be used.'1' gives
#'   the proxdiv operator for the Kullback-Leibler divergence and '2' the opterator
#'   for the total variation.
#' @param alpha num value
#' @param beta num value
#' @return A vector holding the proxdiv evaluation
#' @noRd
NULL

#' The stabilized Scaling Algorithm
#'
#' C++ implementation of the log-domain stabilized Version of the Scaling
#' Algorithm.
#'
#' @param costMatrix A numeric matrix.
#' @param supply A numeric vector
#' @param demand A numeric vector
#' @param lambdaSupply Parameter for the supply proxdiv function
#' @param lambdaDemand Parameter for the demand proxdiv function
#' @param DivSupply Parameter indicating the divergence function to use for the supply proxdiv function
#' @param DivDemand Parameter indicating the divergence function to use for the demand proxdiv function
#' @param iterMax Maximum number of iterations
#' @param epsvec A numeric vector of decreasing epsilon values.
#' @param alphaSupply numeric Value
#' @param betaSupply numeric value
#' @param alphaDemand numeric Value
#' @param betaDemand numeric value
#' @param tol num vale
#'
#' @return The optimal transport plan
#' @noRd
StabilizedScaling_Rcpp <- function(costMatrix, supply, demand, lambdaSupply, alphaSupply, betaSupply, lambdaDemand, alphaDemand, betaDemand, DivSupply, DivDemand, iterMax, epsvec, tol = 1e-7) {
    .Call(`_unbalancedTransport_StabilizedScaling_Rcpp`, costMatrix, supply, demand, lambdaSupply, alphaSupply, betaSupply, lambdaDemand, alphaDemand, betaDemand, DivSupply, DivDemand, iterMax, epsvec, tol)
}

#' initial value for the lambert W function
#' @param x numeric vector
#' @return initial value 
#' @noRd
NULL

#' computing the lambert w function
#' @param x numeric vector
#' @return the function value
#' @noRd 
NULL

#' computing the inital values for the iterators
#' @param x numeric vector
#' @return the function value
#' @noRd
NULL

#' The aprox operator
#'
#' The aprix operators for different divergences in the form of 'lambda * DivFun(.|p)'
#' Implemented are the operators for the Kullback-Leibler divergence and total variation.
#'
#' @param lambda Regularization parameter
#' @param p A numeric vector
#' @param eps The epsilon value
#' @param DivFun A numeric value indicating the function to be used.'1' gives
#'   the proxdiv operator for the Kullback-Leibler divergence and '2' the opterator
#'   for the total variation.
#' @param param1 num value
#' @param param2 num value
#' @return A vector holding the proxdiv evaluation
#' @noRd
NULL

#' matrix mulitplication
#' @param mat num mat
#' @param vec num vec
#' @param Nx num val
#' @param Ny num val
#' @noRd
NULL

#' Inital values
#'
#' The aprix operators for different divergences in the form of 'lambda * DivFun(.|p)'
#' Implemented are the operators for the Kullback-Leibler divergence and total variation.
#'
#' @param lambda Regularization parameter
#' @param costMatrix A numeric matrix
#' @param distribution A numeric vector
#' @param secDistribution A numeric vector
#' @param DivFun A numeric value indicating the function to be used.'1' gives
#'   the proxdiv operator for the Kullback-Leibler divergence and '2' the opterator
#'   for the total variation.
#' @param param1 num value
#' @param param2 num value
#' @param Nx num value
#' @param Ny num value
#' @param eps eps value
#' @return A vector holding the proxdiv evaluation
#' @noRd
NULL

#' The LogSumExp Function
#'
#' @param vec a numeric vector
#' @return The function LogSumExp applied to vec
#' @noRd
NULL

#' Log-Sum-Exp Operator
#'
#' A parallel implementation of the LSE operator used in the iterators of the
#' Sinkhorn algorithm.
#'
#' @param logSup The log values of the input measures
#' @param f the current value of the dual iterator
#' @param costMatrix the cost matrix
#' @param eps Regularization Parameter
#' @param Ny Number of elements in the result vector
#' @noRd
NULL

#' The Sinkhorn Algorithm
#'
#' C++ implementation of the Sinkhorn Algorithm.
#'
#' @param costMatrix A numeric matrix.
#' @param supply A numeric vector
#' @param demand A numeric vector
#' @param lambdaSupply Parameter for the supply proxdiv function
#' @param lambdaDemand Parameter for the demand proxdiv function
#' @param DivSupply Parameter indicating the divergence function to use for the supply proxdiv function
#' @param DivDemand Parameter indicating the divergence function to use for the demand proxdiv function
#' @param iterMax Maximum number of iterations
#' @param eps A numeric vector of decreasing epsilon values.
#' @param param1Supply numeric Value
#' @param param2Supply numeric value
#' @param param1Demand numeric Value
#' @param param2Demand numeric value
#' @param tol numeric value
#'
#' @return The optimal transport plan
#' @noRd
Sinkhorn_Rcpp <- function(costMatrix, supply, demand, lambdaSupply, param1Supply, param2Supply, lambdaDemand, param1Demand, param2Demand, DivSupply, DivDemand, iterMax, epsvec, tol, supdem) {
    .Call(`_unbalancedTransport_Sinkhorn_Rcpp`, costMatrix, supply, demand, lambdaSupply, param1Supply, param2Supply, lambdaDemand, param1Demand, param2Demand, DivSupply, DivDemand, iterMax, epsvec, tol, supdem)
}

#' Helper Function Hausdorff divergence
#'
#' Extending the symmetrical dual solution to the support of the other input measure
#'
#' @param costMatrix A numeric matrix.
#' @param f A numeric vector
#' @param lambda Parameter for the supply proxdiv function
#' @param Div Parameter indicating the divergence function to use for the supply proxdiv function
#' @param eps A numeric vector of decreasing epsilon values.
#' @param param1 numeric Value
#' @param param2 numeric value
#' @param distribution num distrie
#'
#' @return The optimal transport plan
#' @noRd
Hausdorff_Vec_Rcpp <- function(costMatrix, distribution, f, lambda, param1, param2, Div, eps) {
    .Call(`_unbalancedTransport_Hausdorff_Vec_Rcpp`, costMatrix, distribution, f, lambda, param1, param2, Div, eps)
}

#' Updating the segment node values in x < 0
#'
#' This function is used to calculate the step from e_{v,x} to t_{p,x} by subtracting
#' the edge weight from all segment node values in x < 0. If a segment passes through
#' x = 0, it is split in two parts and a new segment node is inserted in to the tree.
#'
#'
#' @param t A segment node.
#' @param k A numeric value. Typically, the distance from the leftmost element to 0.
#' @param c A numeric value. The value that is subtracted from all segment node slopes in x < 0.
#'      If any segment goes through x = 0, the segment is divided in two parts.
#' @return The first segment node in x < 0
#' @noRd
NULL

#' Calcualting the keys and length of all segments with length > 0 in the subtree
#'  of t
#'
#' @param t A node in a segment tree
#' @param keys A vector to store the keys
#' @param length A vector to store the keys
#' @return by reference: Key and length vectors
#' @noRd
NULL

#' The tree metric unbalanced optimal transport algorithm
#'
#' This function makes the unbalanced optimal transport algorithm for tree metrics
#' accessible from R. It calculated the optimal transport cost and the import vector.
#'
#' @param tree A tree structure given in list form. Each entry in the list represents
#'          an edge: (first node, second node, edge weight)
#' @param supply The supply vector.
#' @param demand The demand vector.
#' @param creation A numeric vector giving the creation cost at each node.
#' @param destruction A numeric vector giving the destruction cost at each node.
#' @return A list containing the optimal transport cost and the import vector.
#' @noRd
treegkr_Rcpp <- function(tree, supply, demand, creation, destruction) {
    .Call(`_unbalancedTransport_treegkr_Rcpp`, tree, supply, demand, creation, destruction)
}

