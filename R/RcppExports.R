# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' C++ implementation of the Monge algorithm
#'
#' This function calculates the optimal transport cost and transport
#' plan for unbalanced optimal transport problems with a Monge cost matrix
#'
#'
#' @param costMatrix A numeric matrix that fulfills the Monge property
#' @param supply A numeric vector. Its length must be equal to the numbers of rows in the cost matrix.
#' @param demand A numeric vector. Its length must be equal to the number of column in the cost matrix.
#' @param constructionCost The cost of creating mass at any point.
#' @param destructionCost The cost of destructing mass at any point.
#' @return It returns a list of the transport cost, three numeric vectors that indicate the optimal transport path, and two vectors that indicate
#'     where mass is created and where it is destructed.
#' @noRd
Monge_Rcpp <- function(costMatrix, supply, demand, constructionCost, destructionCost) {
    .Call(`_unbalancedTransport_Monge_Rcpp`, costMatrix, supply, demand, constructionCost, destructionCost)
}

#' Elementwise division of two vectors with 'x/0 = 0'
#'
#' @param a The dividend vector
#' @param b The divisor vector
#' @return solution of elementwise division of a and b
#' @noRd
NULL

#' Elementwise multiplication of two vectors with 'x/0 = 0'
#'
#' @param a The dividend vector
#' @param b The divisor vector
#' @return solution of elementwise division of a and b
#' @noRd
NULL

#' Computing the divergence functions values
#'
#' @param r input vector
#' @param s comparision vector
#' @param DivFun kind of function to use
#' @param param1 lambda or alpha
#' @param param2 beta or 0
#'
#' @noRd
NULL

#' The proxdiv operator
#'
#' The proxdiv operators for different divergences in the form of 'lambda * DivFun(.|p)'
#' Implemented are the operators for the Kullback-Leibler divergence and total variation.
#'
#' @param lambda Regularization parameter
#' @param p A numeric vector
#' @param s A numeric vector
#' @param u A numeric vector
#' @param eps The epsilon value
#' @param DivFun A numeric value indicating the function to be used.'1' gives
#'   the proxdiv operator for the Kullback-Leibler divergence and '2' the opterator
#'   for the total variation.
#' @param alpha num value
#' @param beta num value
#' @return A vector holding the proxdiv evaluation
#' @noRd
NULL

#' Updating the Kernel
#'
#' Calculating and updating the log-domain stabilized kernel. For 0 vectors u and v
#' it calculates the Gibbs kernel.
#'
#' @param u A numeric vector
#' @param v A numeric vector
#' @param eps The epsilon value
#' @param costMatrix A numeric matrix
#' @return The updated kernel
#' @noRd
NULL

#' The stabilized Scaling Algorithm
#'
#' C++ implementation of the log-domain stabilized Version of the Scaling
#' Algorithm.
#'
#' @param costMatrix A numeric matrix.
#' @param supply A numeric vector
#' @param demand A numeric vector
#' @param lambdaSupply Parameter for the supply proxdiv function
#' @param lambdaDemand Parameter for the demand proxdiv function
#' @param DivSupply Parameter indicating the divergence function to use for the supply proxdiv function
#' @param DivDemand Parameter indicating the divergence function to use for the demand proxdiv function
#' @param iterMax Maximum number of iterations
#' @param epsvec A numeric vector of decreasing epsilon values.
#' @param alphaSupply numeric Value
#' @param betaSupply numeric value
#' @param alphaDemand numeric Value
#' @param betaDemand numeric value
#' @param tol num vale
#'
#' @return The optimal transport plan
#' @noRd
StabilizedScaling_Rcpp <- function(costMatrix, supply, demand, lambdaSupply, alphaSupply, betaSupply, lambdaDemand, alphaDemand, betaDemand, DivSupply, DivDemand, iterMax, epsvec, tol = 1e-8) {
    .Call(`_unbalancedTransport_StabilizedScaling_Rcpp`, costMatrix, supply, demand, lambdaSupply, alphaSupply, betaSupply, lambdaDemand, alphaDemand, betaDemand, DivSupply, DivDemand, iterMax, epsvec, tol)
}

#' computing the lambert w function
#' @param x numeric vector
#' @return the function value
#' @noRd 
NULL

#' computing the inital values for f and g
#' @param x numeric vector
#' @return the function value
#' @noRd
NULL

#' The aprox operator
#'
#' The aprix operators for different divergences in the form of 'lambda * DivFun(.|p)'
#' Implemented are the operators for the Kullback-Leibler divergence and total variation.
#'
#' @param lambda Regularization parameter
#' @param p A numeric vector
#' @param eps The epsilon value
#' @param DivFun A numeric value indicating the function to be used.'1' gives
#'   the proxdiv operator for the Kullback-Leibler divergence and '2' the opterator
#'   for the total variation.
#' @param param1 num value
#' @param param2 num value
#' @return A vector holding the proxdiv evaluation
#' @noRd
NULL

#' matrix mulitplication
#' @param mat num mat
#' @param vec num vec
#' @param Nx num val
#' @param Ny num val
#' @noRd
NULL

#' Inital values
#'
#' The aprix operators for different divergences in the form of 'lambda * DivFun(.|p)'
#' Implemented are the operators for the Kullback-Leibler divergence and total variation.
#'
#' @param lambda Regularization parameter
#' @param costMatrix A numeric matrix
#' @param distribution A numeric vector
#' @param secDistribution A numeric vector
#' @param DivFun A numeric value indicating the function to be used.'1' gives
#'   the proxdiv operator for the Kullback-Leibler divergence and '2' the opterator
#'   for the total variation.
#' @param param1 num value
#' @param param2 num value
#' @param Nx num value
#' @param Ny num value
#' @param eps eps value
#' @return A vector holding the proxdiv evaluation
#' @noRd
NULL

#' init the lambert w function
#' @param x numeric vector
#' @return initial value 
#' @noRd
lambertInit <- function(x) {
    .Call(`_unbalancedTransport_lambertInit`, x)
}

#' The stabilized Scaling Algorithm
#'
#' C++ implementation of the log-domain stabilized Version of the Scaling
#' Algorithm.
#'
#' @param costMatrix A numeric matrix.
#' @param supply A numeric vector
#' @param demand A numeric vector
#' @param lambdaSupply Parameter for the supply proxdiv function
#' @param lambdaDemand Parameter for the demand proxdiv function
#' @param DivSupply Parameter indicating the divergence function to use for the supply proxdiv function
#' @param DivDemand Parameter indicating the divergence function to use for the demand proxdiv function
#' @param iterMax Maximum number of iterations
#' @param eps A numeric vector of decreasing epsilon values.
#' @param param1Supply numeric Value
#' @param param2Supply numeric value
#' @param param1Demand numeric Value
#' @param param2Demand numeric value
#' @param tol numeric value
#'
#' @return The optimal transport plan
#' @noRd
Sinkhorn_Rcpp <- function(costMatrix, supply, demand, lambdaSupply, param1Supply, param2Supply, lambdaDemand, param1Demand, param2Demand, DivSupply, DivDemand, iterMax, epsvec, tol) {
    .Call(`_unbalancedTransport_Sinkhorn_Rcpp`, costMatrix, supply, demand, lambdaSupply, param1Supply, param2Supply, lambdaDemand, param1Demand, param2Demand, DivSupply, DivDemand, iterMax, epsvec, tol)
}

#' The symmetric stabilized Scaling Algorithm
#'
#' C++ implementation of the log-domain stabilized Version of the Scaling
#' Algorithm.
#'
#' @param costMatrix A numeric matrix.
#' @param f A numeric vector
#' @param lambda Parameter for the supply proxdiv function
#' @param Div Parameter indicating the divergence function to use for the supply proxdiv function
#' @param eps A numeric vector of decreasing epsilon values.
#' @param param1 numeric Value
#' @param param2 numeric value
#' @param distribution num distrie
#'
#' @return The optimal transport plan
#' @noRd
Hausdorff_Vec_Rcpp <- function(costMatrix, distribution, f, lambda, param1, param2, Div, eps) {
    .Call(`_unbalancedTransport_Hausdorff_Vec_Rcpp`, costMatrix, distribution, f, lambda, param1, param2, Div, eps)
}

#' Updating the segment node values in x < 0
#'
#' This function is used to calculate the step from e_{v,x} to t_{p,x} by subtracting
#' the edge weight from all segment node values in x < 0. If a segment passes through
#' x = 0, it is split in two parts and a new segment node is inserted in to the tree.
#'
#'
#' @param t A segment node.
#' @param k A numeric value. Typically, the distance from the leftmost element to 0.
#' @param c A numeric value. The value that is subtracted from all segment node slopes in x < 0.
#'      If any segment goes through x = 0, the segment is divided in two parts.
#' @return The first segment node in x < 0
#' @noRd
NULL

#' Calcualting the keys and length of all segments with length > 0 in the subtree
#'  of t
#'
#' @param t A node in a segment tree
#' @param keys A vector to store the keys
#' @param length A vector to store the keys
#' @return by reference: Key and length vectors
#' @noRd
NULL

#' The tree metric unbalanced optimal transport algorithm
#'
#' This function makes the unbalanced optimal transport algorithm for tree metrics
#' accessible from R. It calculated the optimal transport cost and the import vector.
#'
#' @param tree A tree structure given in list form. Each entry in the list represents
#'          an edge: (first node, second node, edge weight)
#' @param supply The supply vector.
#' @param demand The demand vector.
#' @param creationCost A numeric vector giving the creation cost at each node.
#' @param destructionCost A numeric vector giving the destruction cost at each node.
#' @return A list containing the optimal transport cost and the import vector.
#' @noRd
treegkr_Rcpp <- function(tree, supply, demand, creation, destruction) {
    .Call(`_unbalancedTransport_treegkr_Rcpp`, tree, supply, demand, creation, destruction)
}

