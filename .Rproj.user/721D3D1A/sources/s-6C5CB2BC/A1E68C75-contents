#' @importFrom grDevices hcl.colors rainbow
#' @importFrom graphics Axis image lines plot polygon points segments text
#'
## usethis namespace: start
#' @useDynLib unbalancedTransport, .registration = TRUE
## usethis namespace: end
NULL
#'
#'
#'
## usethis namespace: start
#' @importFrom Rcpp sourceCpp
## usethis namespace: end
NULL


## usethis namespace: start
#' @import RcppEigen
## usethis namespace: end
NULL


#' @param obj a tree object
#'
#' @title plotUOTP
#' @export
plotUOTP <- function(obj){
    emptyColRow <- max(1, max(nrow(obj$map), ncol(obj$map))/20)

    leftCol <- obj$import
    leftCol[(length(leftCol)+1):(length(leftCol)+1+emptyColRow)] <- rep(NaN, emptyColRow + 1)


    addRows <- matrix(rep(NaN, ncol(obj$map)*emptyColRow), ncol = ncol(obj$map))
    printObj <- rbind(obj$map, addRows ,obj$export)

    addCols <- matrix(rep(NaN, nrow(printObj)*emptyColRow), nrow = nrow(printObj))

    printObj <- cbind(leftCol, addCols, printObj)



    printObj <- t(printObj[nrow(printObj):1,])


    image(printObj, asp = 1, axes = FALSE, ylab = "Supply", xlab = "Demand",
          col=hcl.colors(20, palette = "viridis", alpha = NULL, rev = TRUE, fixup = TRUE))

    #col=heat.colors(20, alpha = 1, rev = TRUE)[c(1:50)])

    att2 <- ((emptyColRow+1):(nrow(printObj)-1))/(nrow(printObj)-1)
    att2 <- att2[seq(1,length(att2), length.out = 10)]
    lab2 <- nrow(obj$map):1
    lab2 <- lab2[seq(1, length(lab2), length.out = 10)]
    att1 <- ((emptyColRow+1):(ncol(printObj)-1))/(ncol(printObj)-1)
    att1 <- att1[seq(1,length(att1), length.out = 10)]
    lab1 <- 1:ncol(obj$map)
    lab1 <- lab1[seq(1, length(lab1), length.out = 10)]
    Axis(side = 2, at = att2, labels = lab2)
    Axis(side = 1, at = att1, labels = lab1)



}



#'
#' @param transportMap map
#' @param supplyList list of the form
#' @param demandList list of the form
#' @param X discretisation
#'
#' @title plot1DTransport
#'
#' @export
plot1DTransport <- function(transportMap,supplyList, demandList, X){

    numIntervals <- 50
    #colors <- hcl.colors(numIntervals, palette = "rainbow", alpha = NULL, rev = FALSE, fixup = TRUE)

    colors <- rainbow(numIntervals, s = 1, v = 1, start = 0, end = max(1, numIntervals - 1)/numIntervals, alpha = 1, rev = FALSE)
    plot(supplyList[[2]], supplyList[[1]], type = "l", lty = 3 , col = "blue", xlab = "Position", ylab = "Mass")
    lines(demandList[[2]], demandList[[1]], type = "l", lty = 3, col = "red")

    fistSupp <- supplyList[[2]][1]
    firstDem <- demandList[[2]][1]
    #case: X == Y

    for( i in 1:numIntervals){
        #for(i in 1:1){
        colSuppInter <- rep(1, length(X))
        colSuppInter[(i-1)/numIntervals > X | i/numIntervals < X] <- 0
        subK <- transportMap * colSuppInter

        #print(subK %*% demandList[[3]])
        #plot(c(0,demandList[[2]]), c(0,subK %*% demandList[[3]]))

        polygon(c(fistSupp,supplyList[[2]]),c(0,t(subK) %*% supplyList[[3]]), col = colors[i])
        polygon(c(firstDem,demandList[[2]]), c(0,subK %*% demandList[[3]]), col = colors[i])
        lines(supplyList[[2]], t(subK) %*% supplyList[[3]], type = "l", col = "black")
        lines(demandList[[2]], subK %*% demandList[[3]], type = "l", col = "black")

    }

    lines(supplyList[[2]], t(transportMap) %*% supplyList[[3]], type = "l", col = "red")
    lines(demandList[[2]], transportMap %*% demandList[[3]], type = "l", col = "blue")

    lines(supplyList[[2]], rep(0, length(supplyList[[2]])), type = "l", col = "black")


}


#' Title nextLayer
#'
#' @param treeDF a tree in data.frame format
#' @param coordinates the coordinates of all tree nodes as data.frame
#' @param node current node
#' @param layer current layer
#'
#' @return data.frame with coordinates and information for all tree nodes
#'
nextLayer <- function(treeDF, coordinates ,node, layer){
    children <- treeDF[treeDF$parent ==node,]$child
    numChildren <- length(children)
    if(numChildren == 0){
        return(coordinates)
    }

    maxX <- coordinates[coordinates$node == node,]$maxX
    minX <- coordinates[coordinates$node == node,]$minX

    distance = (maxX-minX)/numChildren
    for(i in 0:(numChildren-1)){
        coordinates[nrow(coordinates)+1,] <- c(children[i+1], maxX-(i+0.5)*distance,
                                               layer, maxX-(i*distance), maxX - (i+1)*distance, node )
        coordinates = nextLayer(treeDF, coordinates, children[i+1], layer-1)
    }

    return(coordinates)


}


#' Title findPath
#'
#' @param from starting node
#' @param to ending node
#' @param treeDF tree in data.frame format
#'
#' @return the path from 'from' to 'to'
#'
findPath <- function(from, to, treeDF){

    if(length(treeDF[treeDF$parent == from,]$child) > 0){
        children <- treeDF[treeDF$parent == from,]$child

        if(to %in% children){
            return(c(from,to))
        }

        for(i in 1:length(children)){
            path <- findPath(children[i], to, treeDF)
            if(!is.null(path)){
                return(c(from,path))
            }
        }

        return(NULL)
    }else{
        return(NULL)
    }

}


#' Title plotTree
#'
#' @param tree a tree in list format: root node followed by (parent, child, weight)
#' @param tList transport list
#' @param supply supply vector
#' @param demand demand vector
#'
#' @export
#'
plotTree <- function(tree, tList = NULL , supply = NULL, demand = NULL){

    if(length(tList) == 0){
        tList <- NULL

    }

    treeDF <- as.data.frame(do.call(rbind, tree[-1]))
    colnames(treeDF) <- c("parent", "child", "weight")
    treeDF <- treeDF[order(treeDF$parent),]
    rootNode <- tree[1]




    coordinates <- data.frame(c(rootNode, 0, 0, 100,-100,-1))
    colnames(coordinates) <- c("node", "x", "layer", "maxX", "minX", "parent")


    coordinates <- nextLayer(treeDF, coordinates, rootNode, -1)

    maxLayer <- min(coordinates$layer)

    if(!is.null(supply) & !is.null(demand)){
        supDem <- supply-demand
        coordinates$supply <- supDem[coordinates$node]

    }


    plot(1, type = "n", xlab = "", ylab = "", xlim = c(-100, 100), ylim = c(maxLayer,0), axes = FALSE)



    # print edges
    for(i in 1:nrow(treeDF)){
        segments(coordinates[coordinates$node == treeDF[i,]$parent,]$x,
                 coordinates[coordinates$node == treeDF[i,]$parent,]$layer,
                 coordinates[coordinates$node == treeDF[i,]$child,]$x,
                 coordinates[coordinates$node == treeDF[i,]$child,]$layer)
    }



    #if plan given, plot arrows

    if(!is.null(tList)){

        treeDF$tMass <- rep(0, nrow(treeDF))

        for(i in 1:length(tList)){

            #only check the children of from. If it is not a child, the mass has to go up
            pathTo <- unlist(findPath(tList[[i]][1], tList[[i]][2], treeDF))
            pathFrom <- NULL

            if(is.null(pathTo)){

                pathTo <- unlist(findPath(rootNode, tList[[i]][2], treeDF))
                pathFrom <- unlist(findPath(rootNode, tList[[i]][1], treeDF))

                while(length(pathFrom) > 1 & length(pathTo) > 1 & pathFrom[2] == pathTo[2]){
                    pathTo <- pathTo[-1]
                    pathFrom <- pathFrom[-1]

                }


            }

            if(length(pathTo) > 1){

                for(j in 1:(length(pathTo)-1)){
                    treeDF[(treeDF$parent == pathTo[j] & treeDF$child == pathTo[j+1]),]$tMass =
                        tList[[i]][3] + treeDF[(treeDF$parent == pathTo[j] & treeDF$child == pathTo[j+1]),]$tMass
                }

            }
            if(length(pathFrom) > 1){
                for(j in 1:(length(pathFrom)-1)){
                    treeDF[(treeDF$parent == pathFrom[j] & treeDF$child == pathFrom[j+1]),]$tMass =
                        - tList[[i]][3] + treeDF[(treeDF$parent == pathFrom[j] & treeDF$child == pathFrom[j+1]),]$tMass

                }

            }


        }


        arrowsDF <- treeDF[treeDF$tMass != 0, ]

        for(i in 1:nrow(arrowsDF)){

            fromX <- coordinates[coordinates$node == arrowsDF[i,]$parent,]$x
            fromY <- coordinates[coordinates$node == arrowsDF[i,]$parent,]$layer
            toX <- coordinates[coordinates$node == arrowsDF[i,]$child,]$x
            toY <- coordinates[coordinates$node == arrowsDF[i,]$child,]$layer

            shape::Arrows(fromX, fromY, toX, toY, arr.adj = 1, arr.type = "curved",
                   lwd = abs(arrowsDF[i,]$tMass), code = 1.5+0.5*sign(arrowsDF[i,]$tMass) )

        }
    }


    if(is.null(supply) | is.null(demand)){
        points(coordinates$x, coordinates$layer,pch = 19 )


    }else{
        points(coordinates[coordinates$supply  == 0, ]$x, coordinates[coordinates$supply  == 0, ]$layer,
               pch = 19 )

        points(coordinates[coordinates$supply  > 0, ]$x, coordinates[coordinates$supply  > 0, ]$layer,
               pch = 19, cex = abs(coordinates[coordinates$supply > 0, ]$supply),  col = "green")

        points(coordinates[coordinates$supply  < 0, ]$x, coordinates[coordinates$supply  < 0, ]$layer,
               pch = 19, cex = abs(coordinates[coordinates$supply  < 0, ]$supply),  col = "blue")


    }

    text(coordinates$x, coordinates$layer, labels = coordinates$node, pos = 4)

}

